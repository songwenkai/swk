C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE INV_MPU
OBJECT MODULE PLACED IN .\obj\inv_mpu.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\inv_mpu.c LARGE BROWSE ORDER INCDIR(.\inc) DEBUG OBJECTEXTEND PRINT(.\l
                    -ist\inv_mpu.lst) TABS(2) OBJECT(.\obj\inv_mpu.obj)

line level    source

   1          /*
   2           $License:
   3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
   4              See included License.txt for License information.
   5           $
   6           */
   7          /**
   8           *  @addtogroup  DRIVERS Sensor Driver Layer
   9           *  @brief       Hardware drivers to communicate with sensors via I2C.
  10           *
  11           *  @{
  12           *      @file       inv_mpu.c
  13           *      @brief      An I2C-based driver for Invensense gyroscopes.
  14           *      @details    This driver currently works for the following devices:
  15           *                  MPU6050
  16           *                  MPU6500
  17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
  18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
  19           */
  20           //////////////////////////////////////////////////////////////////////////////////  
  21          //STM32 平衡小车程序
  22          //designed by XiaoDaGe
  23          //       
  24          //诗凯科技 @shikaikeji
  25          //QQ交流群: 346431805
  26          //修改日期:2014/5/18
  27          //版本：V1.2
  28          //版权所有，盗版必究。
  29          //淘宝链接：http://item.taobao.com/item.htm?_u=o1o5aod496b0&id=39037359677
  30          //Copyright(C) 诗凯科技 2013-2019
  31          //All rights reserved
  32          //********************************************************************************
  33          //////////////////////////////////////////////////////////////////////////////////   
  34          #include <stdio.h>
  35          //#include <stdint.h>
  36          #include <stdlib.h>
  37          #include <string.h>
  38          #include <math.h>
  39          #include "inv_mpu.h"
  40          #include "iic.h"
  41          //#include "Time.h"
  42          #include "uart.h"
  43          #include "delay.h"
  44          int dmp_set_gyro_bias(long *bias) ;
  45          int dmp_set_accel_bias(long *bias);
  46          
  47          /* The following functions must be defined for this platform:
  48           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
  49           *      unsigned char length, unsigned char const *dat)
  50           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
  51           *      unsigned char length, unsigned char *dat)
  52           * delay_ms(unsigned long num_ms)
  53           * get_ms(unsigned long *count)
  54           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 2   

  55           * labs(long x)
  56           * fabsf(float x)
  57           * min(int a, int b)
  58           */
  59          void run_self_test(void)
  60          {
  61   1          int result;
  62   1      //    char test_packet[4] = {0};
  63   1          long gyro[3], accel[3];
  64   1      
  65   1          result = mpu_run_self_test(gyro, accel);
  66   1          if (result == 0x7) {
  67   2              /* Test passed. We can trust the gyro dat here, so let's push it down
  68   2               * to the DMP.
  69   2               */
  70   2              float sens;
  71   2              unsigned short accel_sens;
  72   2              mpu_get_gyro_sens(&sens);
  73   2              gyro[0] = (long)(gyro[0] * sens);
  74   2              gyro[1] = (long)(gyro[1] * sens);
  75   2              gyro[2] = (long)(gyro[2] * sens);
  76   2              dmp_set_gyro_bias(gyro);
  77   2              mpu_get_accel_sens(&accel_sens);
  78   2              accel[0] *= accel_sens;
  79   2              accel[1] *= accel_sens;
  80   2              accel[2] *= accel_sens;
  81   2              dmp_set_accel_bias(accel);
  82   2        //  PrintChar("setting bias succesfully ......\n");
  83   2          }
  84   1        else
  85   1        {
  86   2        //  PrintChar("bias has not been modified ......\n");
  87   2        }
  88   1      }
  89          
  90           unsigned short inv_orientation_matrix_to_scalar(
  91              const signed char *mtx)
  92          {
  93   1          unsigned short scalar;
  94   1      
  95   1          /*
  96   1             XYZ  010_001_000 Identity Matrix
  97   1             XZY  001_010_000
  98   1             YXZ  010_000_001
  99   1             YZX  000_010_001
 100   1             ZXY  001_000_010
 101   1             ZYX  000_001_010
 102   1           */
 103   1      
 104   1          scalar = inv_row_2_scale(mtx);
 105   1          scalar |= inv_row_2_scale(mtx + 3) << 3;
 106   1          scalar |= inv_row_2_scale(mtx + 6) << 6;
 107   1      
 108   1      
 109   1          return scalar;
 110   1      }
 111           unsigned short inv_row_2_scale(const signed char *row)
 112          {
 113   1          unsigned short b;
 114   1      
 115   1          if (row[0] > 0)
 116   1              b = 0;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 3   

 117   1          else if (row[0] < 0)
 118   1              b = 4;
 119   1          else if (row[1] > 0)
 120   1              b = 1;
 121   1          else if (row[1] < 0)
 122   1              b = 5;
 123   1          else if (row[2] > 0)
 124   1              b = 2;
 125   1          else if (row[2] < 0)
 126   1              b = 6;
 127   1          else
 128   1              b = 7;      // error
 129   1          return b;
 130   1      }
 131          
 132          
 133          void get_ms(unsigned long *time)
 134          {
 135   1      
 136   1      }
*** WARNING C280 IN LINE 133 OF SRC\INV_MPU.C: 'time': unreferenced local variable
 137          
 138          #define MPU6050
 139          #define MOTION_DRIVER_TARGET_MSP430
 140          
 141          #if defined MOTION_DRIVER_TARGET_MSP430
 142          /*#include "msp430.h"
 143          #include "msp430_i2c.h"
 144          #include "msp430_clock.h"
 145          #include "msp430_interrupt.h" */
 146          
 147          #define i2c_write   IIC_Write
 148          #define i2c_read    IIC_Read
 149          #define delay_ms    delay_ms
 150          #define get_ms      get_ms
 151          
 152          //static int reg_int_cb(struct int_param_s *int_param)
 153          //{
 154          //    /*return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
 155          //        int_param->active_low);*/
 156          //    return 0;
 157          //}   
 158          //#define log_i(...)     do {} while (0)
 159          //#define log_e(...)     do {} while (0)
 160          #define log_e    PrintChar
 161          #define log_i    PrintChar
 162          /* labs is already defined by TI's toolchain. */
 163          /* fabs is for doubles. fabsf is for floats. */
 164          #define fabs        fabsf
 165          #define min(a,b) ((a<b)?a:b)
 166          
 167          #elif defined EMPL_TARGET_MSP430
              //#include "msp430.h"
              //#include "msp430_i2c.h"
              //#include "msp430_clock.h"
              //#include "msp430_interrupt.h"
              #include "log.h"
              #define i2c_write   msp430_i2c_write
              #define i2c_read    msp430_i2c_read
              #define delay_ms    msp430_delay_ms
              #define get_ms      msp430_get_clock_ms
              static inline int reg_int_cb(struct int_param_s *int_param)
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 4   

              {
                  return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
                      int_param->active_low);
              }
              #define log_i       MPL_LOGI
              #define log_e       MPL_LOGE
              /* labs is already defined by TI's toolchain. */
              /* fabs is for doubles. fabsf is for floats. */
              #define fabs        fabsf
              #define min(a,b) ((a<b)?a:b)
              #elif defined EMPL_TARGET_UC3L0
              /* Instead of using the standard TWI driver from the ASF library, we're using
               * a TWI driver that follows the slave address + register address convention.
               */
              #include "twi.h"
              #include "delay.h"
              #include "sysclk.h"
              #include "log.h"
              #include "sensors_xplained.h"
              #include "uc3l0_clock.h"
              #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
              #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
              /* delay_ms is a function already defined in ASF. */
              #define get_ms  uc3l0_get_clock_ms
              
              static inline int reg_int_cb(struct int_param_s *int_param)
              {
                  sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
                  return 0;
              }
              #define log_i       MPL_LOGI
              #define log_e       MPL_LOGE
              /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
              #define labs        abs
              #define fabs(x)     (((x)>0)?(x):-(x))
              #else
              //#error  Gyro driver is missing the system layer implementations.
              #endif
 216          
 217          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
              //#error  Which gyro are you using? Define MPUxxxx in your compiler options.
              #endif
 220          
 221          /* Time for some messy macro work. =]
 222           * #define MPU9150
 223           * is equivalent to..
 224           * #define MPU6050
 225           * #define AK8975_SECONDARY
 226           *
 227           * #define MPU9250
 228           * is equivalent to..
 229           * #define MPU6500
 230           * #define AK8963_SECONDARY
 231           */
 232          #if defined MPU9150
              #ifndef MPU6050
              #define MPU6050
              #endif                          /* #ifndef MPU6050 */
              #if defined AK8963_SECONDARY
              #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
              #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
              #define AK8975_SECONDARY
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 5   

              #endif                          /* #if defined AK8963_SECONDARY */
              #elif defined MPU9250           /* #if defined MPU9150 */
              #ifndef MPU6500
              #define MPU6500
              #endif                          /* #ifndef MPU6500 */
              #if defined AK8975_SECONDARY
              #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
              #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
              #define AK8963_SECONDARY
              #endif                          /* #if defined AK8975_SECONDARY */
              #endif                          /* #if defined MPU9150 */
 251          
 252          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
              #define AK89xx_SECONDARY
              #else
 255          /* #warning "No compass = less profit for Invensense. Lame." */
 256          #endif
 257          
 258          static int set_int_enable(unsigned char enable);
 259          
 260          /* Hardware registers needed by driver. */
 261          struct gyro_reg_s {
 262              unsigned char who_am_i;
 263              unsigned char rate_div;
 264              unsigned char lpf;
 265              unsigned char prod_id;
 266              unsigned char user_ctrl;
 267              unsigned char fifo_en;
 268              unsigned char gyro_cfg;
 269              unsigned char accel_cfg;
 270          
 271              //unsigned char accel_cfg2;
 272          
 273              //unsigned char lp_accel_odr;
 274          
 275              unsigned char motion_thr;
 276              unsigned char motion_dur;
 277              unsigned char fifo_count_h;
 278              unsigned char fifo_r_w;
 279              unsigned char raw_gyro;
 280              unsigned char raw_accel;
 281              unsigned char temp;
 282              unsigned char int_enable;
 283              unsigned char dmp_int_status;
 284              unsigned char int_status;
 285          
 286              //unsigned char accel_intel;
 287          
 288              unsigned char pwr_mgmt_1;
 289              unsigned char pwr_mgmt_2;
 290              unsigned char int_pin_cfg;
 291              unsigned char mem_r_w;
 292              unsigned char accel_offs;
 293              unsigned char i2c_mst;
 294              unsigned char bank_sel;
 295              unsigned char mem_start_addr;
 296              unsigned char prgm_start_h;
 297          #if defined AK89xx_SECONDARY
                  unsigned char s0_addr;
                  unsigned char s0_reg;
                  unsigned char s0_ctrl;
                  unsigned char s1_addr;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 6   

                  unsigned char s1_reg;
                  unsigned char s1_ctrl;
                  unsigned char s4_ctrl;
                  unsigned char s0_do;
                  unsigned char s1_do;
                  unsigned char i2c_delay_ctrl;
                  unsigned char raw_compass;
                  /* The I2C_MST_VDDIO bit is in this register. */
                  unsigned char yg_offs_tc;
              #endif
 312          };
 313          
 314          /* Information specific to a particular device. */
 315          struct hw_s {
 316              unsigned char addr;
 317              unsigned short max_fifo;
 318              unsigned char num_reg;
 319              unsigned short temp_sens;
 320              short temp_offset;
 321              unsigned short bank_size;
 322          #if defined AK89xx_SECONDARY
                  unsigned short compass_fsr;
              #endif
 325          };
 326          
 327          /* When entering motion interrupt mode, the driver keeps track of the
 328           * previous state so that it can be restored at a later time.
 329           * TODO: This is tacky. Fix it.
 330           */
 331          struct motion_int_cache_s {
 332              unsigned short gyro_fsr;
 333              unsigned char accel_fsr;
 334              unsigned short lpf;
 335              unsigned short sample_rate;
 336              unsigned char sensors_on;
 337              unsigned char fifo_sensors;
 338              unsigned char dmp_on;
 339          };
 340          
 341          /* Cached chip configuration dat.
 342           * TODO: A lot of these can be handled with a bitmask.
 343           */
 344          struct chip_cfg_s {
 345              /* Matches gyro_cfg >> 3 & 0x03 */
 346              unsigned char gyro_fsr;
 347              /* Matches accel_cfg >> 3 & 0x03 */
 348              unsigned char accel_fsr;
 349              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
 350              unsigned char sensors;
 351              /* Matches config register. */
 352              unsigned char lpf;
 353              unsigned char clk_src;
 354              /* Sample rate, NOT rate divider. */
 355              unsigned short sample_rate;
 356              /* Matches fifo_en register. */
 357              unsigned char fifo_enable;
 358              /* Matches int enable register. */
 359              unsigned char int_enable;
 360              /* 1 if devices on auxiliary I2C bus appear on the primary. */
 361              unsigned char bypass_mode;
 362              /* 1 if half-sensitivity.
 363               * NOTE: This doesn't belong here, but everything else in hw_s is const,
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 7   

 364               * and this allows us to save some precious RAM.
 365               */
 366              unsigned char accel_half;
 367              /* 1 if device in low-power accel-only mode. */
 368              unsigned char lp_accel_mode;
 369              /* 1 if interrupts are only triggered on motion events. */
 370              unsigned char int_motion_only;
 371              struct motion_int_cache_s cache;
 372              /* 1 for active low interrupts. */
 373              unsigned char active_low_int;
 374              /* 1 for latched interrupts. */
 375              unsigned char latched_int;
 376              /* 1 if DMP is enabled. */
 377              unsigned char dmp_on;
 378              /* Ensures that DMP will only be loaded once. */
 379              unsigned char dmp_loaded;
 380              /* Sampling rate used when DMP is enabled. */
 381              unsigned short dmp_sample_rate;
 382          #ifdef AK89xx_SECONDARY
                  /* Compass sample rate. */
                  unsigned short compass_sample_rate;
                  unsigned char compass_addr;
                  short mag_sens_adj[3];
              #endif
 388          };
 389          
 390          /* Information for self-test. */
 391          struct test_s {
 392              unsigned long gyro_sens;
 393              unsigned long accel_sens;
 394              unsigned char reg_rate_div;
 395              unsigned char reg_lpf;
 396              unsigned char reg_gyro_fsr;
 397              unsigned char reg_accel_fsr;
 398              unsigned short wait_ms;
 399              unsigned char packet_thresh;
 400              float min_dps;
 401              float max_dps;
 402              float max_gyro_var;
 403              float min_g;
 404              float max_g;
 405              float max_accel_var;
 406          };
 407          
 408          /* Gyro driver state variables. */
 409          struct gyro_state_s {
 410              const struct gyro_reg_s *reg;
 411              const struct hw_s *hw;
 412              struct chip_cfg_s chip_cfg;
 413              const struct test_s *test;
 414          };
 415          
 416          /* Filter configurations. */
 417          enum lpf_e {
 418              INV_FILTER_256HZ_NOLPF2 = 0,
 419              INV_FILTER_188HZ,
 420              INV_FILTER_98HZ,
 421              INV_FILTER_42HZ,
 422              INV_FILTER_20HZ,
 423              INV_FILTER_10HZ,
 424              INV_FILTER_5HZ,
 425              INV_FILTER_2100HZ_NOLPF,
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 8   

 426              NUM_FILTER
 427          };
 428          
 429          /* Full scale ranges. */
 430          enum gyro_fsr_e {
 431              INV_FSR_250DPS = 0,
 432              INV_FSR_500DPS,
 433              INV_FSR_1000DPS,
 434              INV_FSR_2000DPS,
 435              NUM_GYRO_FSR
 436          };
 437          
 438          /* Full scale ranges. */
 439          enum accel_fsr_e {
 440              INV_FSR_2G = 0,
 441              INV_FSR_4G,
 442              INV_FSR_8G,
 443              INV_FSR_16G,
 444              NUM_ACCEL_FSR
 445          };
 446          
 447          /* Clock sources. */
 448          enum clock_sel_e {
 449              INV_CLK_INTERNAL = 0,
 450              INV_CLK_PLL,
 451              NUM_CLK
 452          };
 453          
 454          /* Low-power accel wakeup rates. */
 455          enum lp_accel_rate_e {
 456          #if defined MPU6050
 457              INV_LPA_1_25HZ,
 458              INV_LPA_5HZ,
 459              INV_LPA_20HZ,
 460              INV_LPA_40HZ
 461          #elif defined MPU6500
                  INV_LPA_0_3125HZ,
                  INV_LPA_0_625HZ,
                  INV_LPA_1_25HZ,
                  INV_LPA_2_5HZ,
                  INV_LPA_5HZ,
                  INV_LPA_10HZ,
                  INV_LPA_20HZ,
                  INV_LPA_40HZ,
                  INV_LPA_80HZ,
                  INV_LPA_160HZ,
                  INV_LPA_320HZ,
                  INV_LPA_640HZ
              #endif
 475          };
 476          
 477          #define BIT_I2C_MST_VDDIO   (0x80)
 478          #define BIT_FIFO_EN         (0x40)
 479          #define BIT_DMP_EN          (0x80)
 480          #define BIT_FIFO_RST        (0x04)
 481          #define BIT_DMP_RST         (0x08)
 482          #define BIT_FIFO_OVERFLOW   (0x10)
 483          #define BIT_dat_RDY_EN     (0x01)
 484          #define BIT_DMP_INT_EN      (0x02)
 485          #define BIT_MOT_INT_EN      (0x40)
 486          #define BITS_FSR            (0x18)
 487          #define BITS_LPF            (0x07)
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 9   

 488          #define BITS_HPF            (0x07)
 489          #define BITS_CLK            (0x07)
 490          #define BIT_FIFO_SIZE_1024  (0x40)
 491          #define BIT_FIFO_SIZE_2048  (0x80)
 492          #define BIT_FIFO_SIZE_4096  (0xC0)
 493          #define BIT_RESET           (0x80)
 494          #define BIT_SLEEP           (0x40)
 495          #define BIT_S0_DELAY_EN     (0x01)
 496          #define BIT_S2_DELAY_EN     (0x04)
 497          #define BITS_SLAVE_LENGTH   (0x0F)
 498          #define BIT_SLAVE_BYTE_SW   (0x40)
 499          #define BIT_SLAVE_GROUP     (0x10)
 500          #define BIT_SLAVE_EN        (0x80)
 501          #define BIT_I2C_READ        (0x80)
 502          #define BITS_I2C_MASTER_DLY (0x1F)
 503          #define BIT_AUX_IF_EN       (0x20)
 504          #define BIT_ACTL            (0x80)
 505          #define BIT_LATCH_EN        (0x20)
 506          #define BIT_ANY_RD_CLR      (0x10)
 507          #define BIT_BYPASS_EN       (0x02)
 508          #define BITS_WOM_EN         (0xC0)
 509          #define BIT_LPA_CYCLE       (0x20)
 510          #define BIT_STBY_XA         (0x20)
 511          #define BIT_STBY_YA         (0x10)
 512          #define BIT_STBY_ZA         (0x08)
 513          #define BIT_STBY_XG         (0x04)
 514          #define BIT_STBY_YG         (0x02)
 515          #define BIT_STBY_ZG         (0x01)
 516          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
 517          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
 518          
 519          #if defined AK8975_SECONDARY
              #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
              #define AK89xx_FSR                  (9830)
              #elif defined AK8963_SECONDARY
              #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
              #define AK89xx_FSR                  (4915)
              #endif
 526          
 527          #ifdef AK89xx_SECONDARY
              #define AKM_REG_WHOAMI      (0x00)
              
              #define AKM_REG_ST1         (0x02)
              #define AKM_REG_HXL         (0x03)
              #define AKM_REG_ST2         (0x09)
              
              #define AKM_REG_CNTL        (0x0A)
              #define AKM_REG_ASTC        (0x0C)
              #define AKM_REG_ASAX        (0x10)
              #define AKM_REG_ASAY        (0x11)
              #define AKM_REG_ASAZ        (0x12)
              
              #define AKM_dat_READY      (0x01)
              #define AKM_dat_OVERRUN    (0x02)
              #define AKM_OVERFLOW        (0x80)
              #define AKM_dat_ERROR      (0x40)
              
              #define AKM_BIT_SELF_TEST   (0x40)
              
              #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
              #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
              #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 10  

              #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
              
              #define AKM_WHOAMI      (0x48)
              #endif
 554          
 555          #if defined MPU6050
 556          /*
 557          const struct gyro_reg_s reg = {
 558             .who_am_i       = 0x75,
 559              .rate_div       = 0x19,
 560              .lpf            = 0x1A,
 561              .prod_id        = 0x0C,
 562              .user_ctrl      = 0x6A,
 563              .fifo_en        = 0x23,
 564              .gyro_cfg       = 0x1B,
 565              .accel_cfg      = 0x1C,
 566              .motion_thr     = 0x1F,
 567              .motion_dur     = 0x20,
 568              .fifo_count_h   = 0x72,
 569              .fifo_r_w       = 0x74,
 570              .raw_gyro       = 0x43,
 571              .raw_accel      = 0x3B,
 572              .temp           = 0x41,
 573              .int_enable     = 0x38,
 574              .dmp_int_status = 0x39,
 575              .int_status     = 0x3A,
 576              .pwr_mgmt_1     = 0x6B,
 577              .pwr_mgmt_2     = 0x6C,
 578              .int_pin_cfg    = 0x37,
 579              .mem_r_w        = 0x6F,
 580              .accel_offs     = 0x06,
 581              .i2c_mst        = 0x24,
 582              .bank_sel       = 0x6D,
 583              .mem_start_addr = 0x6E,
 584              .prgm_start_h   = 0x70
 585          #ifdef AK89xx_SECONDARY
 586              ,.raw_compass   = 0x49,
 587              .yg_offs_tc     = 0x01,
 588              .s0_addr        = 0x25,
 589              .s0_reg         = 0x26,
 590              .s0_ctrl        = 0x27,
 591              .s1_addr        = 0x28,
 592              .s1_reg         = 0x29,
 593              .s1_ctrl        = 0x2A,
 594              .s4_ctrl        = 0x34,
 595              .s0_do          = 0x63,
 596              .s1_do          = 0x64,
 597              .i2c_delay_ctrl = 0x67
 598          #endif
 599          };
 600          const struct hw_s hw = {
 601              .addr           = 0x68,
 602              .max_fifo       = 1024,
 603              .num_reg        = 118,
 604              .temp_sens      = 340,
 605              .temp_offset    = -521,
 606              .bank_size      = 256
 607          #if defined AK89xx_SECONDARY
 608              ,.compass_fsr    = AK89xx_FSR
 609          #endif
 610          };
 611          */
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 11  

 612          const struct hw_s hw={
 613            0x68,  //addr
 614            1024,  //max_fifo
 615            118,   //num_reg
 616            340,   //temp_sens
 617            -521,  //temp_offset
 618            256  //bank_size
 619          };
 620          const struct gyro_reg_s reg = {
 621          0x75,  //who_am_i
 622          0x19,  //rate_div
 623          0x1A,  //lpf
 624          0x0C,  //prod_id
 625          0x6A,  //user_ctrl
 626          0x23,  //fifo_en
 627          0x1B,  //gyro_cfg
 628          0x1C,  //accel_cfg
 629          0x1F,  // motion_thr
 630          0x20,  // motion_dur
 631          0x72,  // fifo_count_h
 632          0x74,  // fifo_r_w
 633          0x43,  // raw_gyro
 634          0x3B,  // raw_accel
 635          0x41,  // temp
 636          0x38,  // int_enable
 637          0x39,  //  dmp_int_status
 638          0x3A,  //  int_status
 639          0x6B,  // pwr_mgmt_1
 640          0x6C,  // pwr_mgmt_2
 641          0x37,  // int_pin_cfg
 642          0x6F,  // mem_r_w
 643          0x06,  // accel_offs
 644          0x24,  // i2c_mst
 645          0x6D,  // bank_sel
 646          0x6E,  // mem_start_addr
 647          0x70   // prgm_start_h
 648          };
 649          
 650          //const struct test_s test = {
 651          //    .gyro_sens      = 32768/250,
 652          //    .accel_sens     = 32768/16,   
 653          //    .reg_rate_div   = 0,    /* 1kHz. */
 654          //    .reg_lpf        = 1,    /* 188Hz. */
 655          //    .reg_gyro_fsr   = 0,    /* 250dps. */
 656          //    .reg_accel_fsr  = 0x18, /* 16g. */
 657          //    .wait_ms        = 50,
 658          //    .packet_thresh  = 5,    /* 5% */
 659          //    .min_dps        = 10.f,
 660          //    .max_dps        = 105.f,
 661          //    .max_gyro_var   = 0.14f,
 662          //    .min_g          = 0.3f,
 663          //    .max_g          = 0.95f,
 664          //    .max_accel_var  = 0.14f
 665          //};
 666          const struct test_s test={
 667          32768/250,     //gyro_sens
 668          32768/16,    // accel_sens
 669          0,         // reg_rate_div
 670          1,        //  reg_lpf
 671          0,         // reg_gyro_fsr
 672          0x18,     //  reg_accel_fsr
 673          50,       //  wait_ms
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 12  

 674          5,        //  packet_thresh
 675          10.0f,       // min_dps
 676          105.0f,      // max_dps
 677          0.14f,      //  max_gyro_var
 678          0.3f,      // min_g
 679          0.95f,       // max_g
 680          0.14f      // max_accel_var
 681          };
 682          /*
 683          static struct gyro_state_s st = {
 684              .reg = &reg,
 685              .hw = &hw,
 686              .test = &test
 687          };  */
 688          static struct gyro_state_s st={
 689            &reg,
 690            &hw,
 691            {0},
 692            &test
 693          };
 694          //st.chip_cfg.dmp_on = 1;
 695          //st.dhip_cfg.fifo_enabel = 1;
 696          /*
 697          #elif defined MPU6500
 698          const struct gyro_reg_s reg = {
 699              .who_am_i       = 0x75,
 700              .rate_div       = 0x19,
 701              .lpf            = 0x1A,
 702              .prod_id        = 0x0C,
 703              .user_ctrl      = 0x6A,
 704              .fifo_en        = 0x23,
 705              .gyro_cfg       = 0x1B,
 706              .accel_cfg      = 0x1C,
 707              .accel_cfg2     = 0x1D,
 708              .lp_accel_odr   = 0x1E,
 709              .motion_thr     = 0x1F,
 710              .motion_dur     = 0x20,
 711              .fifo_count_h   = 0x72,
 712              .fifo_r_w       = 0x74,
 713              .raw_gyro       = 0x43,
 714              .raw_accel      = 0x3B,
 715              .temp           = 0x41,
 716              .int_enable     = 0x38,
 717              .dmp_int_status = 0x39,
 718              .int_status     = 0x3A,
 719              .accel_intel    = 0x69,
 720              .pwr_mgmt_1     = 0x6B,
 721              .pwr_mgmt_2     = 0x6C,
 722              .int_pin_cfg    = 0x37,
 723              .mem_r_w        = 0x6F,
 724              .accel_offs     = 0x77,
 725              .i2c_mst        = 0x24,
 726              .bank_sel       = 0x6D,
 727              .mem_start_addr = 0x6E,
 728              .prgm_start_h   = 0x70
 729          #ifdef AK89xx_SECONDARY
 730              ,.raw_compass   = 0x49,
 731              .s0_addr        = 0x25,
 732              .s0_reg         = 0x26,
 733              .s0_ctrl        = 0x27,
 734              .s1_addr        = 0x28,
 735              .s1_reg         = 0x29,
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 13  

 736              .s1_ctrl        = 0x2A,
 737              .s4_ctrl        = 0x34,
 738              .s0_do          = 0x63,
 739              .s1_do          = 0x64,
 740              .i2c_delay_ctrl = 0x67
 741          #endif
 742          };
 743          const struct hw_s hw = {
 744              .addr           = 0x68,
 745              .max_fifo       = 1024,
 746              .num_reg        = 128,
 747              .temp_sens      = 321,
 748              .temp_offset    = 0,
 749              .bank_size      = 256
 750          #if defined AK89xx_SECONDARY
 751              ,.compass_fsr    = AK89xx_FSR
 752          #endif
 753          };
 754          */
 755          //const struct test_s test = {
 756          //    .gyro_sens      = 32768/250,
 757          //    .accel_sens     = 32768/16,
 758          //    .reg_rate_div   = 0,    /* 1kHz. */
 759          //    .reg_lpf        = 1,    /* 188Hz. */
 760          //    .reg_gyro_fsr   = 0,    /* 250dps. */
 761          //    .reg_accel_fsr  = 0x18, /* 16g. */
 762          //    .wait_ms        = 50,
 763          //    .packet_thresh  = 5,    /* 5% */
 764          //    .min_dps        = 10.f,
 765          //    .max_dps        = 105.f,
 766          //    .max_gyro_var   = 0.14f,
 767          //    .min_g          = 0.3f,
 768          //    .max_g          = 0.95f,
 769          //    .max_accel_var  = 0.14f
 770          //};
 771          //
 772          //static struct gyro_state_s st = {
 773          //    .reg = &reg,
 774          //    .hw = &hw,
 775          //    .test = &test
 776          //};
 777          #endif
 778          
 779          #define MAX_PACKET_LENGTH (12)
 780          
 781          #ifdef AK89xx_SECONDARY
              static int setup_compass(void);
              #define MAX_COMPASS_SAMPLE_RATE (100)
              #endif
 785          
 786          /**
 787           *  @brief      Enable/disable dat ready interrupt.
 788           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the dat ready
 789           *  interrupt is used.
 790           *  @param[in]  enable      1 to enable interrupt.
 791           *  @return     0 if successful.
 792           */
 793          static int set_int_enable(unsigned char enable)
 794          {
 795   1          unsigned char tmp;
 796   1      
 797   1          if (st.chip_cfg.dmp_on) {
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 14  

 798   2              if (enable)
 799   2                  tmp = BIT_DMP_INT_EN;
 800   2              else
 801   2                  tmp = 0x00;
 802   2              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 803   2                  return -1;
 804   2              st.chip_cfg.int_enable = tmp;
 805   2          } else {
 806   2              if (!st.chip_cfg.sensors)
 807   2                  return -1;
 808   2              if (enable && st.chip_cfg.int_enable)
 809   2                  return 0;
 810   2              if (enable)
 811   2                  tmp = BIT_dat_RDY_EN;
 812   2              else
 813   2                  tmp = 0x00;
 814   2              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 815   2                  return -1;
 816   2              st.chip_cfg.int_enable = tmp;
 817   2          }
 818   1          return 0;
 819   1      }
 820          
 821          /**
 822           *  @brief      Register dump for testing.
 823           *  @return     0 if successful.
 824           */
 825          int mpu_reg_dump(void)
 826          {
 827   1          unsigned char ii;
 828   1          unsigned char dat;
 829   1      
 830   1          for (ii = 0; ii < st.hw->num_reg; ii++) {
 831   2              if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 832   2                  continue;
 833   2              if (i2c_read(st.hw->addr, ii, 1, &dat))
 834   2                  return -1;
 835   2              //log_i("%#5x: %#5x\r\n", ii, dat);
 836   2          }
 837   1          return 0;
 838   1      }
 839          
 840          /**
 841           *  @brief      Read from a single register.
 842           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
 843           *  @param[in]  reg     Register address.
 844           *  @param[out] dat    Register dat.
 845           *  @return     0 if successful.
 846           */
 847          int mpu_read_reg(unsigned char reg, unsigned char *dat)
 848          {
 849   1          if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 850   1              return -1;
 851   1          if (reg >= st.hw->num_reg)
 852   1              return -1;
 853   1          return i2c_read(st.hw->addr, reg, 1, dat);
 854   1      }
 855          
 856          /**
 857           *  @brief      Initialize hardware.
 858           *  Initial configuration:\n
 859           *  Gyro FSR: +/- 2000DPS\n
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 15  

 860           *  Accel FSR +/- 2G\n
 861           *  DLPF: 42Hz\n
 862           *  FIFO rate: 50Hz\n
 863           *  Clock source: Gyro PLL\n
 864           *  FIFO: Disabled.\n
 865           *  dat ready interrupt: Disabled, active low, unlatched.
 866           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
 867           *  @return     0 if successful.
 868           */
 869          int mpu_init(void)
 870          {
 871   1          unsigned char dat[6], rev;
 872   1      
 873   1          /* Reset device. */
 874   1          dat[0] = 0x80;//BIT_RESET;
 875   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(dat[0])))
 876   1              return -1;
 877   1          delay_ms(100);
 878   1      
 879   1          /* Wake up chip. */
 880   1          dat[0] = 0x00;
 881   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(dat[0])))
 882   1              return -1;
 883   1      
 884   1      #if defined MPU6050
 885   1          /* Check product revision. */
 886   1          if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, dat))
 887   1              return -1;
 888   1          rev = ((dat[5] & 0x01) << 2) | ((dat[3] & 0x01) << 1) |
 889   1              (dat[1] & 0x01);
 890   1      
 891   1          if (rev) {
 892   2              /* Congrats, these parts are better. */
 893   2              if (rev == 1)
 894   2                  st.chip_cfg.accel_half = 1;
 895   2              else if (rev == 2)
 896   2                  st.chip_cfg.accel_half = 0;
 897   2              else {
 898   3      //            log_e("Unsupported software product rev %d.\n");
 899   3                  return -1;
 900   3              }
 901   2          } else {
 902   2              if (i2c_read(st.hw->addr, st.reg->prod_id, 1, &(dat[0])))
 903   2                  return -1;
 904   2              rev = dat[0] & 0x0F;
 905   2              if (!rev) {
 906   3        //          log_e("Product ID read as 0 indicates device is either "
 907   3      //                "incompatible or an MPU3050.\n");
 908   3                  return -1;
 909   3              } else if (rev == 4) {
 910   3      //            log_i("Half sensitivity part found.\n");
 911   3                  st.chip_cfg.accel_half = 1;
 912   3              } else
 913   2                  st.chip_cfg.accel_half = 0;
 914   2          }
 915   1      #elif defined MPU6500
              #define MPU6500_MEM_REV_ADDR    (0x17)
                  if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
                      return -1;
                  if (rev == 0x1)
                      st.chip_cfg.accel_half = 0;
                  else {
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 16  

                //      log_e("Unsupported software product rev %d.\n", rev);
                      return -1;
                  }
              
                  /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
                   * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
                   */
                  dat[0] = BIT_FIFO_SIZE_1024 | 0x8;
                  if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, dat))
                      return -1;
              #endif
 933   1      
 934   1          /* Set to invalid values to ensure no I2C writes are skipped. */
 935   1          st.chip_cfg.sensors = 0xFF;
 936   1          st.chip_cfg.gyro_fsr = 0xFF;
 937   1          st.chip_cfg.accel_fsr = 0xFF;
 938   1          st.chip_cfg.lpf = 0xFF;
 939   1          st.chip_cfg.sample_rate = 0xFFFF;
 940   1          st.chip_cfg.fifo_enable = 0xFF;
 941   1          st.chip_cfg.bypass_mode = 0xFF;
 942   1      #ifdef AK89xx_SECONDARY
                  st.chip_cfg.compass_sample_rate = 0xFFFF;
              #endif
 945   1          /* mpu_set_sensors always preserves this setting. */
 946   1          st.chip_cfg.clk_src = INV_CLK_PLL;
 947   1          /* Handled in next call to mpu_set_bypass. */
 948   1          st.chip_cfg.active_low_int = 1;
 949   1          st.chip_cfg.latched_int = 0;
 950   1          st.chip_cfg.int_motion_only = 0;
 951   1          st.chip_cfg.lp_accel_mode = 0;
 952   1          memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 953   1          st.chip_cfg.dmp_on = 0;
 954   1          st.chip_cfg.dmp_loaded = 0;
 955   1          st.chip_cfg.dmp_sample_rate = 0;
 956   1      
 957   1          if (mpu_set_gyro_fsr(2000))
 958   1              return -1;
 959   1          if (mpu_set_accel_fsr(2))
 960   1              return -1;
 961   1          if (mpu_set_lpf(42))
 962   1              return -1;
 963   1          if (mpu_set_sample_rate(50))
 964   1              return -1;
 965   1          if (mpu_configure_fifo(0))
 966   1              return -1;
 967   1      
 968   1          /*if (int_param)
 969   1              reg_int_cb(int_param);*/
 970   1      
 971   1      #ifdef AK89xx_SECONDARY
                  setup_compass();
                  if (mpu_set_compass_sample_rate(10))
                      return -1;
              #else
 976   1          /* Already disabled by setup_compass. */
 977   1          if (mpu_set_bypass(0))
 978   1              return -1;
 979   1      #endif
 980   1      
 981   1          mpu_set_sensors(0);
 982   1          return 0;
 983   1      }
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 17  

 984          
 985          /**
 986           *  @brief      Enter low-power accel-only mode.
 987           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
 988           *  the accelerometer at one of the following frequencies:
 989           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
 990           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
 991           *  \n If the requested rate is not one listed above, the device will be set to
 992           *  the next highest rate. Requesting a rate above the maximum supported
 993           *  frequency will result in an error.
 994           *  \n To select a fractional wake-up frequency, round down the value passed to
 995           *  @e rate.
 996           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
 997           *                          accel mode.
 998           *  @return     0 if successful.
 999           */
1000          int mpu_lp_accel_mode(unsigned char rate)
1001          {
1002   1          unsigned char tmp[2];
1003   1      
1004   1          if (rate > 40)
1005   1              return -1;
1006   1      
1007   1          if (!rate) {
1008   2              mpu_set_int_latched(0);
1009   2              tmp[0] = 0;
1010   2              tmp[1] = BIT_STBY_XYZG;
1011   2              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
1012   2                  return -1;
1013   2              st.chip_cfg.lp_accel_mode = 0;
1014   2              return 0;
1015   2          }
1016   1          /* For LP accel, we automatically configure the hardware to produce latched
1017   1           * interrupts. In LP accel mode, the hardware cycles into sleep mode before
1018   1           * it gets a chance to deassert the interrupt pin; therefore, we shift this
1019   1           * responsibility over to the MCU.
1020   1           *
1021   1           * Any register read will clear the interrupt.
1022   1           */
1023   1          mpu_set_int_latched(1);
1024   1      #if defined MPU6050
1025   1          tmp[0] = BIT_LPA_CYCLE;
1026   1          if (rate == 1) {
1027   2              tmp[1] = INV_LPA_1_25HZ;
1028   2              mpu_set_lpf(5);
1029   2          } else if (rate <= 5) {
1030   2              tmp[1] = INV_LPA_5HZ;
1031   2              mpu_set_lpf(5);
1032   2          } else if (rate <= 20) {
1033   2              tmp[1] = INV_LPA_20HZ;
1034   2              mpu_set_lpf(10);
1035   2          } else {
1036   2              tmp[1] = INV_LPA_40HZ;
1037   2              mpu_set_lpf(20);
1038   2          }
1039   1          tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
1040   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
1041   1              return -1;
1042   1      #elif defined MPU6500
                  /* Set wake frequency. */
                  if (rate == 1)
                      tmp[0] = INV_LPA_1_25HZ;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 18  

                  else if (rate == 2)
                      tmp[0] = INV_LPA_2_5HZ;
                  else if (rate <= 5)
                      tmp[0] = INV_LPA_5HZ;
                  else if (rate <= 10)
                      tmp[0] = INV_LPA_10HZ;
                  else if (rate <= 20)
                      tmp[0] = INV_LPA_20HZ;
                  else if (rate <= 40)
                      tmp[0] = INV_LPA_40HZ;
                  else if (rate <= 80)
                      tmp[0] = INV_LPA_80HZ;
                  else if (rate <= 160)
                      tmp[0] = INV_LPA_160HZ;
                  else if (rate <= 320)
                      tmp[0] = INV_LPA_320HZ;
                  else
                      tmp[0] = INV_LPA_640HZ;
                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
                      return -1;
                  tmp[0] = BIT_LPA_CYCLE;
                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
                      return -1;
              #endif
1070   1          st.chip_cfg.sensors = INV_XYZ_ACCEL;
1071   1          st.chip_cfg.clk_src = 0;
1072   1          st.chip_cfg.lp_accel_mode = 1;
1073   1          mpu_configure_fifo(0);
1074   1      
1075   1          return 0;
1076   1      }
1077          
1078          /**
1079           *  @brief      Read raw gyro dat directly from the registers.
1080           *  @param[out] dat        Raw dat in hardware units.
1081           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
1082           *  @return     0 if successful.
1083           */
1084          int mpu_get_gyro_reg(short *dat, unsigned long *timestamp)
1085          {
1086   1          unsigned char tmp[6];
1087   1      
1088   1          if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
1089   1              return -1;
1090   1      
1091   1          if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
1092   1              return -1;
1093   1          dat[0] = (tmp[0] << 8) | tmp[1];
1094   1          dat[1] = (tmp[2] << 8) | tmp[3];
1095   1          dat[2] = (tmp[4] << 8) | tmp[5];
1096   1      //    if (timestamp)
1097   1      //        get_ms(timestamp);
1098   1          return 0;
1099   1      }
*** WARNING C280 IN LINE 1084 OF SRC\INV_MPU.C: 'timestamp': unreferenced local variable
1100          
1101          /**
1102           *  @brief      Read raw accel dat directly from the registers.
1103           *  @param[out] dat        Raw dat in hardware units.
1104           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
1105           *  @return     0 if successful.
1106           */
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 19  

1107          int mpu_get_accel_reg(short *dat, unsigned long *timestamp)
1108          {
1109   1          unsigned char tmp[6];
1110   1      
1111   1          if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
1112   1              return -1;
1113   1      
1114   1          if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
1115   1              return -1;
1116   1          dat[0] = (tmp[0] << 8) | tmp[1];
1117   1          dat[1] = (tmp[2] << 8) | tmp[3];
1118   1          dat[2] = (tmp[4] << 8) | tmp[5];
1119   1          if (timestamp)
1120   1              get_ms(timestamp);
1121   1          return 0;
1122   1      }
1123          
1124          /**
1125           *  @brief      Read temperature dat directly from the registers.
1126           *  @param[out] dat        dat in q16 format.
1127           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
1128           *  @return     0 if successful.
1129           */
1130          int mpu_get_temperature(long *dat, unsigned long *timestamp)
1131          {
1132   1          unsigned char tmp[2];
1133   1          short raw;
1134   1      
1135   1          if (!(st.chip_cfg.sensors))
1136   1              return -1;
1137   1      
1138   1          if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
1139   1              return -1;
1140   1          raw = (tmp[0] << 8) | tmp[1];
1141   1          if (timestamp)
1142   1              get_ms(timestamp);
1143   1      
1144   1          dat[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
1145   1          return 0;
1146   1      }
1147          
1148          /**
1149           *  @brief      Push biases to the accel bias registers.
1150           *  This function expects biases relative to the current sensor output, and
1151           *  these biases will be added to the factory-supplied values.
1152           *  @param[in]  accel_bias  New biases.
1153           *  @return     0 if successful.
1154           */
1155          int mpu_set_accel_bias(const long *accel_bias)
1156          {
1157   1          unsigned char dat[6];
1158   1          short accel_hw[3];
1159   1          short got_accel[3];
1160   1          short fg[3];
1161   1      
1162   1          if (!accel_bias)
1163   1              return -1;
1164   1          if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
1165   1              return 0;
1166   1      
1167   1          if (i2c_read(st.hw->addr, 3, 3, dat))
1168   1              return -1;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 20  

1169   1          fg[0] = ((dat[0] >> 4) + 8) & 0xf;
1170   1          fg[1] = ((dat[1] >> 4) + 8) & 0xf;
1171   1          fg[2] = ((dat[2] >> 4) + 8) & 0xf;
1172   1      
1173   1          accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
1174   1          accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
1175   1          accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
1176   1      
1177   1          if (i2c_read(st.hw->addr, 0x06, 6, dat))
1178   1              return -1;
1179   1      
1180   1          got_accel[0] = ((short)dat[0] << 8) | dat[1];
1181   1          got_accel[1] = ((short)dat[2] << 8) | dat[3];
1182   1          got_accel[2] = ((short)dat[4] << 8) | dat[5];
1183   1      
1184   1          accel_hw[0] += got_accel[0];
1185   1          accel_hw[1] += got_accel[1];
1186   1          accel_hw[2] += got_accel[2];
1187   1      
1188   1          dat[0] = (accel_hw[0] >> 8) & 0xff;
1189   1          dat[1] = (accel_hw[0]) & 0xff;
1190   1          dat[2] = (accel_hw[1] >> 8) & 0xff;
1191   1          dat[3] = (accel_hw[1]) & 0xff;
1192   1          dat[4] = (accel_hw[2] >> 8) & 0xff;
1193   1          dat[5] = (accel_hw[2]) & 0xff;
1194   1      
1195   1          if (i2c_write(st.hw->addr, 0x06, 6, dat))
1196   1              return -1;
1197   1          return 0;
1198   1      }
1199          
1200          /**
1201           *  @brief  Reset FIFO read/write pointers.
1202           *  @return 0 if successful.
1203           */
1204          int mpu_reset_fifo(void)
1205          {
1206   1          unsigned char dat;
1207   1      
1208   1          if (!(st.chip_cfg.sensors))
1209   1              return -1;
1210   1      
1211   1          dat = 0;
1212   1          if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &dat))
1213   1              return -1;
1214   1          if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &dat))
1215   1              return -1;
1216   1          if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &dat))
1217   1              return -1;
1218   1      
1219   1          if (st.chip_cfg.dmp_on) {
1220   2              dat = BIT_FIFO_RST | BIT_DMP_RST;
1221   2              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &dat))
1222   2                  return -1;
1223   2              delay_ms(50);
1224   2              dat = BIT_DMP_EN | BIT_FIFO_EN;
1225   2              if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1226   2                  dat |= BIT_AUX_IF_EN;
1227   2              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &dat))
1228   2                  return -1;
1229   2              if (st.chip_cfg.int_enable)
1230   2                  dat = BIT_DMP_INT_EN;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 21  

1231   2              else
1232   2                  dat = 0;
1233   2              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &dat))
1234   2                  return -1;
1235   2              dat = 0;
1236   2              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &dat))
1237   2                  return -1;
1238   2          } else {
1239   2              dat = BIT_FIFO_RST;
1240   2              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &dat))
1241   2                  return -1;
1242   2              if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
1243   2                  dat = BIT_FIFO_EN;
1244   2              else
1245   2                  dat = BIT_FIFO_EN | BIT_AUX_IF_EN;
1246   2              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &dat))
1247   2                  return -1;
1248   2              delay_ms(50);
1249   2              if (st.chip_cfg.int_enable)
1250   2                  dat = BIT_dat_RDY_EN;
1251   2              else
1252   2                  dat = 0;
1253   2              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &dat))
1254   2                  return -1;
1255   2              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
1256   2                  return -1;
1257   2          }
1258   1          return 0;
1259   1      }
1260          
1261          /**
1262           *  @brief      Get the gyro full-scale range.
1263           *  @param[out] fsr Current full-scale range.
1264           *  @return     0 if successful.
1265           */
1266          int mpu_get_gyro_fsr(unsigned short *fsr)
1267          {
1268   1          switch (st.chip_cfg.gyro_fsr) {
1269   2          case INV_FSR_250DPS:
1270   2              fsr[0] = 250;
1271   2              break;
1272   2          case INV_FSR_500DPS:
1273   2              fsr[0] = 500;
1274   2              break;
1275   2          case INV_FSR_1000DPS:
1276   2              fsr[0] = 1000;
1277   2              break;
1278   2          case INV_FSR_2000DPS:
1279   2              fsr[0] = 2000;
1280   2              break;
1281   2          default:
1282   2              fsr[0] = 0;
1283   2              break;
1284   2          }
1285   1          return 0;
1286   1      }
1287          
1288          /**
1289           *  @brief      Set the gyro full-scale range.
1290           *  @param[in]  fsr Desired full-scale range.
1291           *  @return     0 if successful.
1292           */
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 22  

1293          int mpu_set_gyro_fsr(unsigned short fsr)
1294          {
1295   1          unsigned char dat;
1296   1      
1297   1          if (!(st.chip_cfg.sensors))
1298   1              return -1;
1299   1      
1300   1          switch (fsr) {
1301   2          case 250:
1302   2              dat = INV_FSR_250DPS << 3;
1303   2              break;
1304   2          case 500:
1305   2              dat = INV_FSR_500DPS << 3;
1306   2              break;
1307   2          case 1000:
1308   2              dat = INV_FSR_1000DPS << 3;
1309   2              break;
1310   2          case 2000:
1311   2              dat = INV_FSR_2000DPS << 3;
1312   2              break;
1313   2          default:
1314   2              return -1;
1315   2          }
1316   1      
1317   1          if (st.chip_cfg.gyro_fsr == (dat >> 3))
1318   1              return 0;
1319   1          if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &dat))
1320   1              return -1;
1321   1          st.chip_cfg.gyro_fsr = dat >> 3;
1322   1          return 0;
1323   1      }
1324          
1325          /**
1326           *  @brief      Get the accel full-scale range.
1327           *  @param[out] fsr Current full-scale range.
1328           *  @return     0 if successful.
1329           */
1330          int mpu_get_accel_fsr(unsigned char *fsr)
1331          {
1332   1          switch (st.chip_cfg.accel_fsr) {
1333   2          case INV_FSR_2G:
1334   2              fsr[0] = 2;
1335   2              break;
1336   2          case INV_FSR_4G:
1337   2              fsr[0] = 4;
1338   2              break;
1339   2          case INV_FSR_8G:
1340   2              fsr[0] = 8;
1341   2              break;
1342   2          case INV_FSR_16G:
1343   2              fsr[0] = 16;
1344   2              break;
1345   2          default:
1346   2              return -1;
1347   2          }
1348   1          if (st.chip_cfg.accel_half)
1349   1              fsr[0] <<= 1;
1350   1          return 0;
1351   1      }
1352          
1353          /**
1354           *  @brief      Set the accel full-scale range.
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 23  

1355           *  @param[in]  fsr Desired full-scale range.
1356           *  @return     0 if successful.
1357           */
1358          int mpu_set_accel_fsr(unsigned char fsr)
1359          {
1360   1          unsigned char dat;
1361   1      
1362   1          if (!(st.chip_cfg.sensors))
1363   1              return -1;
1364   1      
1365   1          switch (fsr) {
1366   2          case 2:
1367   2              dat = INV_FSR_2G << 3;
1368   2              break;
1369   2          case 4:
1370   2              dat = INV_FSR_4G << 3;
1371   2              break;
1372   2          case 8:
1373   2              dat = INV_FSR_8G << 3;
1374   2              break;
1375   2          case 16:
1376   2              dat = INV_FSR_16G << 3;
1377   2              break;
1378   2          default:
1379   2              return -1;
1380   2          }
1381   1      
1382   1          if (st.chip_cfg.accel_fsr == (dat >> 3))
1383   1              return 0;
1384   1          if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &dat))
1385   1              return -1;
1386   1          st.chip_cfg.accel_fsr = dat >> 3;
1387   1          return 0;
1388   1      }
1389          
1390          /**
1391           *  @brief      Get the current DLPF setting.
1392           *  @param[out] lpf Current LPF setting.
1393           *  0 if successful.
1394           */
1395          int mpu_get_lpf(unsigned short *lpf)
1396          {
1397   1          switch (st.chip_cfg.lpf) {
1398   2          case INV_FILTER_188HZ:
1399   2              lpf[0] = 188;
1400   2              break;
1401   2          case INV_FILTER_98HZ:
1402   2              lpf[0] = 98;
1403   2              break;
1404   2          case INV_FILTER_42HZ:
1405   2              lpf[0] = 42;
1406   2              break;
1407   2          case INV_FILTER_20HZ:
1408   2              lpf[0] = 20;
1409   2              break;
1410   2          case INV_FILTER_10HZ:
1411   2              lpf[0] = 10;
1412   2              break;
1413   2          case INV_FILTER_5HZ:
1414   2              lpf[0] = 5;
1415   2              break;
1416   2          case INV_FILTER_256HZ_NOLPF2:
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 24  

1417   2          case INV_FILTER_2100HZ_NOLPF:
1418   2          default:
1419   2              lpf[0] = 0;
1420   2              break;
1421   2          }
1422   1          return 0;
1423   1      }
1424          
1425          /**
1426           *  @brief      Set digital low pass filter.
1427           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
1428           *  @param[in]  lpf Desired LPF setting.
1429           *  @return     0 if successful.
1430           */
1431          int mpu_set_lpf(unsigned short lpf)
1432          {
1433   1          unsigned char dat;
1434   1      
1435   1          if (!(st.chip_cfg.sensors))
1436   1              return -1;
1437   1      
1438   1          if (lpf >= 188)
1439   1              dat = INV_FILTER_188HZ;
1440   1          else if (lpf >= 98)
1441   1              dat = INV_FILTER_98HZ;
1442   1          else if (lpf >= 42)
1443   1              dat = INV_FILTER_42HZ;
1444   1          else if (lpf >= 20)
1445   1              dat = INV_FILTER_20HZ;
1446   1          else if (lpf >= 10)
1447   1              dat = INV_FILTER_10HZ;
1448   1          else
1449   1              dat = INV_FILTER_5HZ;
1450   1      
1451   1          if (st.chip_cfg.lpf == dat)
1452   1              return 0;
1453   1          if (i2c_write(st.hw->addr, st.reg->lpf, 1, &dat))
1454   1              return -1;
1455   1          st.chip_cfg.lpf = dat;
1456   1          return 0;
1457   1      }
1458          
1459          /**
1460           *  @brief      Get sampling rate.
1461           *  @param[out] rate    Current sampling rate (Hz).
1462           *  @return     0 if successful.
1463           */
1464          int mpu_get_sample_rate(unsigned short *rate)
1465          {
1466   1          if (st.chip_cfg.dmp_on)
1467   1              return -1;
1468   1          else
1469   1              rate[0] = st.chip_cfg.sample_rate;
1470   1          return 0;
1471   1      }
1472          
1473          /**
1474           *  @brief      Set sampling rate.
1475           *  Sampling rate must be between 4Hz and 1kHz.
1476           *  @param[in]  rate    Desired sampling rate (Hz).
1477           *  @return     0 if successful.
1478           */
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 25  

1479          int mpu_set_sample_rate(unsigned short rate)
1480          {
1481   1          unsigned char dat;
1482   1      
1483   1          if (!(st.chip_cfg.sensors))
1484   1              return -1;
1485   1      
1486   1          if (st.chip_cfg.dmp_on)
1487   1              return -1;
1488   1          else {
1489   2              if (st.chip_cfg.lp_accel_mode) {
1490   3                  if (rate && (rate <= 40)) {
1491   4                      /* Just stay in low-power accel mode. */
1492   4                      mpu_lp_accel_mode(rate);
1493   4                      return 0;
1494   4                  }
1495   3                  /* Requested rate exceeds the allowed frequencies in LP accel mode,
1496   3                   * switch back to full-power mode.
1497   3                   */
1498   3                  mpu_lp_accel_mode(0);
1499   3              }
1500   2              if (rate < 4)
1501   2                  rate = 4;
1502   2              else if (rate > 1000)
1503   2                  rate = 1000;
1504   2      
1505   2              dat = 1000 / rate - 1;
1506   2              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &dat))
1507   2                  return -1;
1508   2      
1509   2              st.chip_cfg.sample_rate = 1000 / (1 + dat);
1510   2      
1511   2      #ifdef AK89xx_SECONDARY
                      mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
              #endif
1514   2      
1515   2              /* Automatically set LPF to 1/2 sampling rate. */
1516   2              mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
1517   2              return 0;
1518   2          }
1519   1      }
1520          
1521          /**
1522           *  @brief      Get compass sampling rate.
1523           *  @param[out] rate    Current compass sampling rate (Hz).
1524           *  @return     0 if successful.
1525           */
1526          int mpu_get_compass_sample_rate(unsigned short *rate)
1527          {
1528   1      #ifdef AK89xx_SECONDARY
                  rate[0] = st.chip_cfg.compass_sample_rate;
                  return 0;
              #else
1532   1          rate[0] = 0;
1533   1          return -1;
1534   1      #endif
1535   1      }
1536          
1537          /**
1538           *  @brief      Set compass sampling rate.
1539           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
1540           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 26  

1541           *  sampling rate.
1542           *
1543           *  \n WARNING: The new rate may be different than what was requested. Call
1544           *  mpu_get_compass_sample_rate to check the actual setting.
1545           *  @param[in]  rate    Desired compass sampling rate (Hz).
1546           *  @return     0 if successful.
1547           */
1548          int mpu_set_compass_sample_rate(unsigned short rate)
1549          {
1550   1      #ifdef AK89xx_SECONDARY
                  unsigned char div;
                  if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
                      return -1;
              
                  div = st.chip_cfg.sample_rate / rate - 1;
                  if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
                      return -1;
                  st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
                  return 0;
              #else
1561   1          return -1;
1562   1      #endif
1563   1      }
*** WARNING C280 IN LINE 1548 OF SRC\INV_MPU.C: 'rate': unreferenced local variable
1564          
1565          /**
1566           *  @brief      Get gyro sensitivity scale factor.
1567           *  @param[out] sens    Conversion from hardware units to dps.
1568           *  @return     0 if successful.
1569           */
1570          int mpu_get_gyro_sens(float *sens)
1571          {
1572   1          switch (st.chip_cfg.gyro_fsr) {
1573   2          case INV_FSR_250DPS:
1574   2              sens[0] = 131.f;
1575   2              break;
1576   2          case INV_FSR_500DPS:
1577   2              sens[0] = 65.5f;
1578   2              break;
1579   2          case INV_FSR_1000DPS:
1580   2              sens[0] = 32.8f;
1581   2              break;
1582   2          case INV_FSR_2000DPS:
1583   2              sens[0] = 16.4f;
1584   2              break;
1585   2          default:
1586   2              return -1;
1587   2          }
1588   1          return 0;
1589   1      }
1590          
1591          /**
1592           *  @brief      Get accel sensitivity scale factor.
1593           *  @param[out] sens    Conversion from hardware units to g's.
1594           *  @return     0 if successful.
1595           */
1596          int mpu_get_accel_sens(unsigned short *sens)
1597          {
1598   1          switch (st.chip_cfg.accel_fsr) {
1599   2          case INV_FSR_2G:
1600   2              sens[0] = 16384;
1601   2              break;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 27  

1602   2          case INV_FSR_4G:
1603   2              sens[0] = 8092;
1604   2              break;
1605   2          case INV_FSR_8G:
1606   2              sens[0] = 4096;
1607   2              break;
1608   2          case INV_FSR_16G:
1609   2              sens[0] = 2048;
1610   2              break;
1611   2          default:
1612   2              return -1;
1613   2          }
1614   1          if (st.chip_cfg.accel_half)
1615   1              sens[0] >>= 1;
1616   1          return 0;
1617   1      }
1618          
1619          /**
1620           *  @brief      Get current FIFO configuration.
1621           *  @e sensors can contain a combination of the following flags:
1622           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1623           *  \n INV_XYZ_GYRO
1624           *  \n INV_XYZ_ACCEL
1625           *  @param[out] sensors Mask of sensors in FIFO.
1626           *  @return     0 if successful.
1627           */
1628          int mpu_get_fifo_config(unsigned char *sensors)
1629          {
1630   1          sensors[0] = st.chip_cfg.fifo_enable;
1631   1          return 0;
1632   1      }
1633          
1634          /**
1635           *  @brief      Select which sensors are pushed to FIFO.
1636           *  @e sensors can contain a combination of the following flags:
1637           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1638           *  \n INV_XYZ_GYRO
1639           *  \n INV_XYZ_ACCEL
1640           *  @param[in]  sensors Mask of sensors to push to FIFO.
1641           *  @return     0 if successful.
1642           */
1643          int mpu_configure_fifo(unsigned char sensors)
1644          {
1645   1          unsigned char prev;
1646   1          int result = 0;
1647   1      
1648   1          /* Compass dat isn't going into the FIFO. Stop trying. */
1649   1          sensors &= ~INV_XYZ_COMPASS;
1650   1      
1651   1          if (st.chip_cfg.dmp_on)
1652   1              return 0;
1653   1          else {
1654   2              if (!(st.chip_cfg.sensors))
1655   2                  return -1;
1656   2              prev = st.chip_cfg.fifo_enable;
1657   2              st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
1658   2              if (st.chip_cfg.fifo_enable != sensors)
1659   2                  /* You're not getting what you asked for. Some sensors are
1660   2                   * asleep.
1661   2                   */
1662   2                  result = -1;
1663   2              else
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 28  

1664   2                  result = 0;
1665   2              if (sensors || st.chip_cfg.lp_accel_mode)
1666   2                  set_int_enable(1);
1667   2              else
1668   2                  set_int_enable(0);
1669   2              if (sensors) {
1670   3                  if (mpu_reset_fifo()) {
1671   4                      st.chip_cfg.fifo_enable = prev;
1672   4                      return -1;
1673   4                  }
1674   3              }
1675   2          }
1676   1      
1677   1          return result;
1678   1      }
1679          
1680          /**
1681           *  @brief      Get current power state.
1682           *  @param[in]  power_on    1 if turned on, 0 if suspended.
1683           *  @return     0 if successful.
1684           */
1685          int mpu_get_power_state(unsigned char *power_on)
1686          {
1687   1          if (st.chip_cfg.sensors)
1688   1              power_on[0] = 1;
1689   1          else
1690   1              power_on[0] = 0;
1691   1          return 0;
1692   1      }
1693          
1694          /**
1695           *  @brief      Turn specific sensors on/off.
1696           *  @e sensors can contain a combination of the following flags:
1697           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1698           *  \n INV_XYZ_GYRO
1699           *  \n INV_XYZ_ACCEL
1700           *  \n INV_XYZ_COMPASS
1701           *  @param[in]  sensors    Mask of sensors to wake.
1702           *  @return     0 if successful.
1703           */
1704          int mpu_set_sensors(unsigned char sensors)
1705          {
1706   1          unsigned char dat;
1707   1      #ifdef AK89xx_SECONDARY
                  unsigned char user_ctrl;
              #endif
1710   1      
1711   1          if (sensors & INV_XYZ_GYRO)
1712   1              dat = INV_CLK_PLL;
1713   1          else if (sensors)
1714   1              dat = 0;
1715   1          else
1716   1              dat = BIT_SLEEP;
1717   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &dat)) {
1718   2              st.chip_cfg.sensors = 0;
1719   2              return -1;
1720   2          }
1721   1          st.chip_cfg.clk_src = dat & ~BIT_SLEEP;
1722   1      
1723   1          dat = 0;
1724   1          if (!(sensors & INV_X_GYRO))
1725   1              dat |= BIT_STBY_XG;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 29  

1726   1          if (!(sensors & INV_Y_GYRO))
1727   1              dat |= BIT_STBY_YG;
1728   1          if (!(sensors & INV_Z_GYRO))
1729   1              dat |= BIT_STBY_ZG;
1730   1          if (!(sensors & INV_XYZ_ACCEL))
1731   1              dat |= BIT_STBY_XYZA;
1732   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &dat)) {
1733   2              st.chip_cfg.sensors = 0;
1734   2              return -1;
1735   2          }
1736   1      
1737   1          if (sensors && (sensors != INV_XYZ_ACCEL))
1738   1              /* Latched interrupts only used in LP accel mode. */
1739   1              mpu_set_int_latched(0);
1740   1      
1741   1      #ifdef AK89xx_SECONDARY
              #ifdef AK89xx_BYPASS
                  if (sensors & INV_XYZ_COMPASS)
                      mpu_set_bypass(1);
                  else
                      mpu_set_bypass(0);
              #else
                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
                      return -1;
                  /* Handle AKM power management. */
                  if (sensors & INV_XYZ_COMPASS) {
                      dat = AKM_SINGLE_MEASUREMENT;
                      user_ctrl |= BIT_AUX_IF_EN;
                  } else {
                      dat = AKM_POWER_DOWN;
                      user_ctrl &= ~BIT_AUX_IF_EN;
                  }
                  if (st.chip_cfg.dmp_on)
                      user_ctrl |= BIT_DMP_EN;
                  else
                      user_ctrl &= ~BIT_DMP_EN;
                  if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &dat))
                      return -1;
                  /* Enable/disable I2C master mode. */
                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
                      return -1;
              #endif
              #endif
1769   1      
1770   1          st.chip_cfg.sensors = sensors;
1771   1          st.chip_cfg.lp_accel_mode = 0;
1772   1          delay_ms(50);
1773   1          return 0;
1774   1      }
1775          
1776          /**
1777           *  @brief      Read the MPU interrupt status registers.
1778           *  @param[out] status  Mask of interrupt bits.
1779           *  @return     0 if successful.
1780           */
1781          int mpu_get_int_status(short *status)
1782          {
1783   1          unsigned char tmp[2];
1784   1          if (!st.chip_cfg.sensors)
1785   1              return -1;
1786   1          if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
1787   1              return -1;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 30  

1788   1          status[0] = (tmp[0] << 8) | tmp[1];
1789   1          return 0;
1790   1      }
1791          
1792          /**
1793           *  @brief      Get one packet from the FIFO.
1794           *  If @e sensors does not contain a particular sensor, disregard the dat
1795           *  returned to that pointer.
1796           *  \n @e sensors can contain a combination of the following flags:
1797           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1798           *  \n INV_XYZ_GYRO
1799           *  \n INV_XYZ_ACCEL
1800           *  \n If the FIFO has no new dat, @e sensors will be zero.
1801           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
1802           *  return a non-zero error code.
1803           *  @param[out] gyro        Gyro dat in hardware units.
1804           *  @param[out] accel       Accel dat in hardware units.
1805           *  @param[out] timestamp   Timestamp in milliseconds.
1806           *  @param[out] sensors     Mask of sensors read from FIFO.
1807           *  @param[out] more        Number of remaining packets.
1808           *  @return     0 if successful.
1809           */
1810          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
1811                  unsigned char *sensors, unsigned char *more)
1812          {
1813   1          /* Assumes maximum packet size is gyro (6) + accel (6). */
1814   1          unsigned char dat[MAX_PACKET_LENGTH];
1815   1          unsigned char packet_size = 0;
1816   1          unsigned short fifo_count, index = 0;
1817   1      
1818   1          if (st.chip_cfg.dmp_on)
1819   1              return -1;
1820   1      
1821   1          sensors[0] = 0;
1822   1          if (!st.chip_cfg.sensors)
1823   1              return -1;
1824   1          if (!st.chip_cfg.fifo_enable)
1825   1              return -1;
1826   1      
1827   1          if (st.chip_cfg.fifo_enable & INV_X_GYRO)
1828   1              packet_size += 2;
1829   1          if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
1830   1              packet_size += 2;
1831   1          if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
1832   1              packet_size += 2;
1833   1          if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
1834   1              packet_size += 6;
1835   1      
1836   1          if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, dat))
1837   1              return -1;
1838   1          fifo_count = (dat[0] << 8) | dat[1];
1839   1          if (fifo_count < packet_size)
1840   1              return 0;
1841   1      //    log_i("FIFO count: %hd\n", fifo_count);
1842   1          if (fifo_count > (st.hw->max_fifo >> 1)) {
1843   2              /* FIFO is 50% full, better check overflow bit. */
1844   2              if (i2c_read(st.hw->addr, st.reg->int_status, 1, dat))
1845   2                  return -1;
1846   2              if (dat[0] & BIT_FIFO_OVERFLOW) {
1847   3                  mpu_reset_fifo();
1848   3                  return -2;
1849   3              }
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 31  

1850   2          }
1851   1          get_ms((unsigned long*)timestamp);
1852   1      
1853   1          if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, dat))
1854   1              return -1;
1855   1          more[0] = fifo_count / packet_size - 1;
1856   1          sensors[0] = 0;
1857   1      
1858   1          if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
1859   2              accel[0] = (dat[index+0] << 8) | dat[index+1];
1860   2              accel[1] = (dat[index+2] << 8) | dat[index+3];
1861   2              accel[2] = (dat[index+4] << 8) | dat[index+5];
1862   2              sensors[0] |= INV_XYZ_ACCEL;
1863   2              index += 6;
1864   2          }
1865   1          if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
1866   2              gyro[0] = (dat[index+0] << 8) | dat[index+1];
1867   2              sensors[0] |= INV_X_GYRO;
1868   2              index += 2;
1869   2          }
1870   1          if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
1871   2              gyro[1] = (dat[index+0] << 8) | dat[index+1];
1872   2              sensors[0] |= INV_Y_GYRO;
1873   2              index += 2;
1874   2          }
1875   1          if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
1876   2              gyro[2] = (dat[index+0] << 8) | dat[index+1];
1877   2              sensors[0] |= INV_Z_GYRO;
1878   2              index += 2;
1879   2          }
1880   1      
1881   1          return 0;
1882   1      }
1883          
1884          /**
1885           *  @brief      Get one unparsed packet from the FIFO.
1886           *  This function should be used if the packet is to be parsed elsewhere.
1887           *  @param[in]  length  Length of one FIFO packet.
1888           *  @param[in]  dat    FIFO packet.
1889           *  @param[in]  more    Number of remaining packets.
1890           */
1891          int mpu_read_fifo_stream(unsigned short length, unsigned char *dat,
1892              unsigned char *more)
1893          {
1894   1          unsigned char tmp[2];
1895   1          unsigned short fifo_count;
1896   1          if (!st.chip_cfg.dmp_on)
1897   1              return -1;
1898   1          if (!st.chip_cfg.sensors)
1899   1              return -1;
1900   1      
1901   1          if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
1902   1              return -1;
1903   1          fifo_count = (tmp[0] << 8) | tmp[1];
1904   1          if (fifo_count < length) {
1905   2              more[0] = 0;
1906   2              return -1;
1907   2          }
1908   1          if (fifo_count > (st.hw->max_fifo >> 1)) {
1909   2              /* FIFO is 50% full, better check overflow bit. */
1910   2              if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
1911   2                  return -1;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 32  

1912   2              if (tmp[0] & BIT_FIFO_OVERFLOW) {
1913   3                  mpu_reset_fifo();
1914   3                  return -2;
1915   3              }
1916   2          }
1917   1      
1918   1          if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, dat))
1919   1              return -1;
1920   1          more[0] = fifo_count / length - 1;
1921   1          return 0;
1922   1      }
1923          
1924          /**
1925           *  @brief      Set device to bypass mode.
1926           *  @param[in]  bypass_on   1 to enable bypass mode.
1927           *  @return     0 if successful.
1928           */
1929          int mpu_set_bypass(unsigned char bypass_on)
1930          {
1931   1          unsigned char tmp;
1932   1      
1933   1          if (st.chip_cfg.bypass_mode == bypass_on)
1934   1              return 0;
1935   1      
1936   1          if (bypass_on) {
1937   2              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1938   2                  return -1;
1939   2              tmp &= ~BIT_AUX_IF_EN;
1940   2              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1941   2                  return -1;
1942   2              delay_ms(3);
1943   2              tmp = BIT_BYPASS_EN;
1944   2              if (st.chip_cfg.active_low_int)
1945   2                  tmp |= BIT_ACTL;
1946   2              if (st.chip_cfg.latched_int)
1947   2                  tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1948   2              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1949   2                  return -1;
1950   2          } else {
1951   2              /* Enable I2C master mode if compass is being used. */
1952   2              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1953   2                  return -1;
1954   2              if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1955   2                  tmp |= BIT_AUX_IF_EN;
1956   2              else
1957   2                  tmp &= ~BIT_AUX_IF_EN;
1958   2              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1959   2                  return -1;
1960   2              delay_ms(3);
1961   2              if (st.chip_cfg.active_low_int)
1962   2                  tmp = BIT_ACTL;
1963   2              else
1964   2                  tmp = 0;
1965   2              if (st.chip_cfg.latched_int)
1966   2                  tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1967   2              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1968   2                  return -1;
1969   2          }
1970   1          st.chip_cfg.bypass_mode = bypass_on;
1971   1          return 0;
1972   1      }
1973          
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 33  

1974          /**
1975           *  @brief      Set interrupt level.
1976           *  @param[in]  active_low  1 for active low, 0 for active high.
1977           *  @return     0 if successful.
1978           */
1979          int mpu_set_int_level(unsigned char active_low)
1980          {
1981   1          st.chip_cfg.active_low_int = active_low;
1982   1          return 0;
1983   1      }
1984          
1985          /**
1986           *  @brief      Enable latched interrupts.
1987           *  Any MPU register will clear the interrupt.
1988           *  @param[in]  enable  1 to enable, 0 to disable.
1989           *  @return     0 if successful.
1990           */
1991          int mpu_set_int_latched(unsigned char enable)
1992          {
1993   1          unsigned char tmp;
1994   1          if (st.chip_cfg.latched_int == enable)
1995   1              return 0;
1996   1      
1997   1          if (enable)
1998   1              tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
1999   1          else
2000   1              tmp = 0;
2001   1          if (st.chip_cfg.bypass_mode)
2002   1              tmp |= BIT_BYPASS_EN;
2003   1          if (st.chip_cfg.active_low_int)
2004   1              tmp |= BIT_ACTL;
2005   1          if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
2006   1              return -1;
2007   1          st.chip_cfg.latched_int = enable;
2008   1          return 0;
2009   1      }
2010          
2011          #ifdef MPU6050
2012          static int get_accel_prod_shift(float *st_shift)
2013          {
2014   1          unsigned char tmp[4], shift_code[3], ii;
2015   1      
2016   1          if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
2017   1              return 0x07;
2018   1      
2019   1          shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
2020   1          shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
2021   1          shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
2022   1          for (ii = 0; ii < 3; ii++) {
2023   2              if (!shift_code[ii]) {
2024   3                  st_shift[ii] = 0.f;
2025   3                  continue;
2026   3              }
2027   2              /* Equivalent to..
2028   2               * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
2029   2               */
2030   2              st_shift[ii] = 0.34f;
2031   2              while (--shift_code[ii])
2032   2                  st_shift[ii] *= 1.034f;
2033   2          }
2034   1          return 0;
2035   1      }
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 34  

2036          
2037          static int accel_self_test(long *bias_regular, long *bias_st)
2038          {
2039   1          int jj, result = 0;
2040   1          float st_shift[3], st_shift_cust, st_shift_var;
2041   1      
2042   1          get_accel_prod_shift(st_shift);
2043   1          for(jj = 0; jj < 3; jj++) {
2044   2            //  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
2045   2              if (st_shift[jj]) {
2046   3            //       if (fabs(st_shift_var) > test.max_accel_var)
2047   3                      result |= 1 << jj;
2048   3              } else if ((st_shift_cust < test.min_g) ||
2049   2                  (st_shift_cust > test.max_g))
2050   2                  result |= 1 << jj;
2051   2          }
2052   1      
2053   1          return result;
2054   1      }
*** WARNING C280 IN LINE 2037 OF SRC\INV_MPU.C: 'bias_regular': unreferenced local variable
*** WARNING C280 IN LINE 2037 OF SRC\INV_MPU.C: 'bias_st': unreferenced local variable
*** WARNING C280 IN LINE 2040 OF SRC\INV_MPU.C: 'st_shift_var': unreferenced local variable
2055          
2056          static int gyro_self_test(long *bias_regular, long *bias_st)
2057          {
2058   1          int jj, result = 0;
2059   1          unsigned char tmp[3];
2060   1          float st_shift, st_shift_cust, st_shift_var;
2061   1      
2062   1          if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
2063   1              return 0x07;
2064   1      
2065   1          tmp[0] &= 0x1F;
2066   1          tmp[1] &= 0x1F;
2067   1          tmp[2] &= 0x1F;
2068   1      
2069   1          for (jj = 0; jj < 3; jj++) {
2070   2             // st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
2071   2              if (tmp[jj]) {
2072   3                  st_shift = 3275.f / test.gyro_sens;
2073   3                  while (--tmp[jj])
2074   3             //         st_shift *= 1.046f;
2075   3             //     st_shift_var = st_shift_cust / st_shift - 1.f;
2076   3                  if (fabs(st_shift_var) > test.max_gyro_var)
*** WARNING C206 IN LINE 2076 OF SRC\INV_MPU.C: 'fabsf': missing function-prototype
*** ERROR C267 IN LINE 2076 OF SRC\INV_MPU.C: 'fabsf': requires ANSI-style prototype
2077   3                      result |= 1 << jj;
2078   3              } else if ((st_shift_cust < test.min_dps) ||
2079   2                  (st_shift_cust > test.max_dps))
2080   2                  result |= 1 << jj;
2081   2          }
2082   1          return result;
2083   1      }
2084          
2085          #ifdef AK89xx_SECONDARY
              static int compass_self_test(void)
              {
                  unsigned char tmp[6];
                  unsigned char tries = 10;
                  int result = 0x07;
                  short dat;
              
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 35  

                  mpu_set_bypass(1);
              
                  tmp[0] = AKM_POWER_DOWN;
                  if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
                      return 0x07;
                  tmp[0] = AKM_BIT_SELF_TEST;
                  if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
                      goto AKM_restore;
                  tmp[0] = AKM_MODE_SELF_TEST;
                  if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
                      goto AKM_restore;
              
                  do {
                      delay_ms(10);
                      if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
                          goto AKM_restore;
                      if (tmp[0] & AKM_dat_READY)
                          break;
                  } while (tries--);
                  if (!(tmp[0] & AKM_dat_READY))
                      goto AKM_restore;
              
                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
                      goto AKM_restore;
              
                  result = 0;
                  dat = (short)(tmp[1] << 8) | tmp[0];
                  if ((dat > 100) || (dat < -100))
                      result |= 0x01;
                  dat = (short)(tmp[3] << 8) | tmp[2];
                  if ((dat > 100) || (dat < -100))
                      result |= 0x02;
                  dat = (short)(tmp[5] << 8) | tmp[4];
                  if ((dat > -300) || (dat < -1000))
                      result |= 0x04;
              
              AKM_restore:
                  tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
                  i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
                  tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
                  i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
                  mpu_set_bypass(0);
                  return result;
              }
              #endif
2138          #endif
2139          
2140          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
2141          {
2142   1          unsigned char dat[MAX_PACKET_LENGTH];
2143   1          unsigned char packet_count, ii;
2144   1          unsigned short fifo_count;
2145   1      
2146   1          dat[0] = 0x01;
2147   1          dat[1] = 0;
2148   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, dat))
2149   1              return -1;
2150   1          delay_ms(200);
2151   1          dat[0] = 0;
2152   1          if (i2c_write(st.hw->addr, st.reg->int_enable, 1, dat))
2153   1              return -1;
2154   1          if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, dat))
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 36  

2155   1              return -1;
2156   1          if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, dat))
2157   1              return -1;
2158   1          if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, dat))
2159   1              return -1;
2160   1          if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, dat))
2161   1              return -1;
2162   1          dat[0] = BIT_FIFO_RST | BIT_DMP_RST;
2163   1          if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, dat))
2164   1              return -1;
2165   1          delay_ms(15);
2166   1          dat[0] = st.test->reg_lpf;
2167   1          if (i2c_write(st.hw->addr, st.reg->lpf, 1, dat))
2168   1              return -1;
2169   1          dat[0] = st.test->reg_rate_div;
2170   1          if (i2c_write(st.hw->addr, st.reg->rate_div, 1, dat))
2171   1              return -1;
2172   1          if (hw_test)
2173   1              dat[0] = st.test->reg_gyro_fsr | 0xE0;
2174   1          else
2175   1              dat[0] = st.test->reg_gyro_fsr;
2176   1          if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, dat))
2177   1              return -1;
2178   1      
2179   1          if (hw_test)
2180   1              dat[0] = st.test->reg_accel_fsr | 0xE0;
2181   1          else
2182   1              dat[0] = test.reg_accel_fsr;
2183   1          if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, dat))
2184   1              return -1;
2185   1          if (hw_test)
2186   1              delay_ms(200);
2187   1      
2188   1          /* Fill FIFO for test.wait_ms milliseconds. */
2189   1          dat[0] = BIT_FIFO_EN;
2190   1          if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, dat))
2191   1              return -1;
2192   1      
2193   1          dat[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2194   1          if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, dat))
2195   1              return -1;
2196   1          delay_ms(test.wait_ms);
2197   1          dat[0] = 0;
2198   1          if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, dat))
2199   1              return -1;
2200   1      
2201   1          if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, dat))
2202   1              return -1;
2203   1      
2204   1          fifo_count = (dat[0] << 8) | dat[1];
2205   1          packet_count = fifo_count / MAX_PACKET_LENGTH;
2206   1          gyro[0] = gyro[1] = gyro[2] = 0;
2207   1          accel[0] = accel[1] = accel[2] = 0;
2208   1      
2209   1          for (ii = 0; ii < packet_count; ii++) {
2210   2              short accel_cur[3], gyro_cur[3];
2211   2              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, dat))
2212   2                  return -1;
2213   2              accel_cur[0] = ((short)dat[0] << 8) | dat[1];
2214   2              accel_cur[1] = ((short)dat[2] << 8) | dat[3];
2215   2              accel_cur[2] = ((short)dat[4] << 8) | dat[5];
2216   2              accel[0] += (long)accel_cur[0];
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 37  

2217   2              accel[1] += (long)accel_cur[1];
2218   2              accel[2] += (long)accel_cur[2];
2219   2              gyro_cur[0] = (((short)dat[6] << 8) | dat[7]);
2220   2              gyro_cur[1] = (((short)dat[8] << 8) | dat[9]);
2221   2              gyro_cur[2] = (((short)dat[10] << 8) | dat[11]);
2222   2              gyro[0] += (long)gyro_cur[0];
2223   2              gyro[1] += (long)gyro_cur[1];
2224   2              gyro[2] += (long)gyro_cur[2];
2225   2          }
2226   1      #ifdef EMPL_NO_64BIT
                  gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
                  gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
                  gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
                  if (has_accel) {
                      accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
                          packet_count);
                      accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
                          packet_count);
                      accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
                          packet_count);
                      /* Don't remove gravity! */
                      accel[2] -= 65536L;
                  }
              #else
2241   1          gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
*** ERROR C141 IN LINE 2241 OF SRC\INV_MPU.C: syntax error near 'long', expected ')'
2242   1          gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
*** ERROR C141 IN LINE 2242 OF SRC\INV_MPU.C: syntax error near 'long', expected ')'
2243   1          gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
*** ERROR C141 IN LINE 2243 OF SRC\INV_MPU.C: syntax error near 'long', expected ')'
2244   1          accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
*** ERROR C141 IN LINE 2244 OF SRC\INV_MPU.C: syntax error near 'long', expected ')'
2245   1              packet_count);
2246   1          accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
*** ERROR C141 IN LINE 2246 OF SRC\INV_MPU.C: syntax error near 'long', expected ')'
2247   1              packet_count);
2248   1          accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
*** ERROR C141 IN LINE 2248 OF SRC\INV_MPU.C: syntax error near 'long', expected ')'
2249   1              packet_count);
2250   1          /* Don't remove gravity! */
2251   1          if (accel[2] > 0L)
2252   1              accel[2] -= 65536L;
2253   1          else
2254   1              accel[2] += 65536L;
2255   1      #endif
2256   1      
2257   1          return 0;
2258   1      }
2259          
2260          /**
2261           *  @brief      Trigger gyro/accel/compass self-test.
2262           *  On success/error, the self-test returns a mask representing the sensor(s)
2263           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
2264           *  a zero (0) indicates a failure.
2265           *
2266           *  \n The mask is defined as follows:
2267           *  \n Bit 0:   Gyro.
2268           *  \n Bit 1:   Accel.
2269           *  \n Bit 2:   Compass.
2270           *
2271           *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
2272           *  this function can still be used to obtain the accel and gyro biases.
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 38  

2273           *
2274           *  \n This function must be called with the device either face-up or face-down
2275           *  (z-axis is parallel to gravity).
2276           *  @param[out] gyro        Gyro biases in q16 format.
2277           *  @param[out] accel       Accel biases (if applicable) in q16 format.
2278           *  @return     Result mask (see above).
2279           */
2280          int mpu_run_self_test(long *gyro, long *accel)
2281          {
2282   1      #ifdef MPU6050
2283   1          const unsigned char tries = 2;
2284   1          long gyro_st[3], accel_st[3];
2285   1          unsigned char accel_result, gyro_result;
2286   1      #ifdef AK89xx_SECONDARY
                  unsigned char compass_result;
              #endif
2289   1          int ii;
2290   1      #endif
2291   1          int result;
2292   1          unsigned char accel_fsr, fifo_sensors, sensors_on;
2293   1          unsigned short gyro_fsr, sample_rate, lpf;
2294   1          unsigned char dmp_was_on;
2295   1      
2296   1          if (st.chip_cfg.dmp_on) {
2297   2              mpu_set_dmp_state(0);
2298   2              dmp_was_on = 1;
2299   2          } else
2300   1              dmp_was_on = 0;
2301   1      
2302   1          /* Get initial settings. */
2303   1          mpu_get_gyro_fsr(&gyro_fsr);
2304   1          mpu_get_accel_fsr(&accel_fsr);
2305   1          mpu_get_lpf(&lpf);
2306   1          mpu_get_sample_rate(&sample_rate);
2307   1          sensors_on = st.chip_cfg.sensors;
2308   1          mpu_get_fifo_config(&fifo_sensors);
2309   1      
2310   1          /* For older chips, the self-test will be different. */
2311   1      #if defined MPU6050
2312   1          for (ii = 0; ii < tries; ii++)
2313   1              if (!get_st_biases(gyro, accel, 0))
2314   1                  break;
2315   1          if (ii == tries) {
2316   2              /* If we reach this point, we most likely encountered an I2C error.
2317   2               * We'll just report an error for all three sensors.
2318   2               */
2319   2              result = 0;
2320   2              goto restore;
2321   2          }
2322   1          for (ii = 0; ii < tries; ii++)
2323   1              if (!get_st_biases(gyro_st, accel_st, 1))
2324   1                  break;
2325   1          if (ii == tries) {
2326   2              /* Again, probably an I2C error. */
2327   2              result = 0;
2328   2              goto restore;
2329   2          }
2330   1          accel_result = accel_self_test(accel, accel_st);
2331   1          gyro_result = gyro_self_test(gyro, gyro_st);
2332   1      
2333   1          result = 0;
2334   1          if (!gyro_result)
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 39  

2335   1              result |= 0x01;
2336   1          if (!accel_result)
2337   1              result |= 0x02;
2338   1      
2339   1      #ifdef AK89xx_SECONDARY
                  compass_result = compass_self_test();
                  if (!compass_result)
                      result |= 0x04;
              #endif
2344   1      restore:
2345   1      #elif defined MPU6500
                  /* For now, this function will return a "pass" result for all three sensors
                   * for compatibility with current test applications.
                   */
                  get_st_biases(gyro, accel, 0);
                  result = 0x7;
              #endif
2352   1          /* Set to invalid values to ensure no I2C writes are skipped. */
2353   1          st.chip_cfg.gyro_fsr = 0xFF;
2354   1          st.chip_cfg.accel_fsr = 0xFF;
2355   1          st.chip_cfg.lpf = 0xFF;
2356   1          st.chip_cfg.sample_rate = 0xFFFF;
2357   1          st.chip_cfg.sensors = 0xFF;
2358   1          st.chip_cfg.fifo_enable = 0xFF;
2359   1          st.chip_cfg.clk_src = INV_CLK_PLL;
2360   1          mpu_set_gyro_fsr(gyro_fsr);
2361   1          mpu_set_accel_fsr(accel_fsr);
2362   1          mpu_set_lpf(lpf);
2363   1          mpu_set_sample_rate(sample_rate);
2364   1          mpu_set_sensors(sensors_on);
2365   1          mpu_configure_fifo(fifo_sensors);
2366   1      
2367   1          if (dmp_was_on)
2368   1              mpu_set_dmp_state(1);
2369   1      
2370   1          return result;
2371   1      }
2372          
2373          /**
2374           *  @brief      Write to the DMP memory.
2375           *  This function prevents I2C writes past the bank boundaries. The DMP memory
2376           *  is only accessible when the chip is awake.
2377           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2378           *  @param[in]  length      Number of bytes to write.
2379           *  @param[in]  dat        Bytes to write to memory.
2380           *  @return     0 if successful.
2381           */
2382          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
2383                  unsigned char *dat)
2384          {
2385   1          unsigned char tmp[2];
2386   1      
2387   1          if (!dat)
2388   1              return -1;
2389   1          if (!st.chip_cfg.sensors)
2390   1              return -1;
2391   1      
2392   1          tmp[0] = (unsigned char)(mem_addr >> 8);
2393   1          tmp[1] = (unsigned char)(mem_addr & 0xFF);
2394   1      
2395   1          /* Check bank boundaries. */
2396   1          if (tmp[1] + length > st.hw->bank_size)
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 40  

2397   1              return -1;
2398   1      
2399   1          if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2400   1              return -1;
2401   1          if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, dat))
2402   1              return -1;
2403   1          return 0;
2404   1      }
2405          
2406          /**
2407           *  @brief      Read from the DMP memory.
2408           *  This function prevents I2C reads past the bank boundaries. The DMP memory
2409           *  is only accessible when the chip is awake.
2410           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2411           *  @param[in]  length      Number of bytes to read.
2412           *  @param[out] dat        Bytes read from memory.
2413           *  @return     0 if successful.
2414           */
2415          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
2416                  unsigned char *dat)
2417          {
2418   1          unsigned char tmp[2];
2419   1      
2420   1          if (!dat)
2421   1              return -1;
2422   1          if (!st.chip_cfg.sensors)
2423   1              return -1;
2424   1      
2425   1          tmp[0] = (unsigned char)(mem_addr >> 8);
2426   1          tmp[1] = (unsigned char)(mem_addr & 0xFF);
2427   1      
2428   1          /* Check bank boundaries. */
2429   1          if (tmp[1] + length > st.hw->bank_size)
2430   1              return -1;
2431   1      
2432   1          if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2433   1              return -1;
2434   1          if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, dat))
2435   1              return -1;
2436   1          return 0;
2437   1      }
2438          
2439          /**
2440           *  @brief      Load and verify DMP image.
2441           *  @param[in]  length      Length of DMP image.
2442           *  @param[in]  firmware    DMP code.
2443           *  @param[in]  start_addr  Starting address of DMP code memory.
2444           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
2445           *  @return     0 if successful.
2446           */
2447          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
2448              unsigned short start_addr, unsigned short sample_rate)
2449          {
2450   1          unsigned short ii;
2451   1          unsigned short this_write;
2452   1          /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
2453   1      #define LOAD_CHUNK  (16)
2454   1          unsigned char cur[LOAD_CHUNK], tmp[2];
2455   1      
2456   1          if (st.chip_cfg.dmp_loaded)
2457   1              /* DMP should only be loaded once. */
2458   1              return -1;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 41  

2459   1      
2460   1          if (!firmware)
2461   1              return -1;
2462   1          for (ii = 0; ii < length; ii += this_write) {
2463   2              this_write = min(LOAD_CHUNK, length - ii);
2464   2              if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
2465   2                  return -1;
2466   2              if (mpu_read_mem(ii, this_write, cur))
2467   2                  return -1;
2468   2              if (memcmp(firmware+ii, cur, this_write))
2469   2                  return -2;
2470   2          }
2471   1      
2472   1          /* Set program start address. */
2473   1          tmp[0] = start_addr >> 8;
2474   1          tmp[1] = start_addr & 0xFF;
2475   1          if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
2476   1              return -1;
2477   1      
2478   1          st.chip_cfg.dmp_loaded = 1;
2479   1          st.chip_cfg.dmp_sample_rate = sample_rate;
2480   1          return 0;
2481   1      }
2482          
2483          /**
2484           *  @brief      Enable/disable DMP support.
2485           *  @param[in]  enable  1 to turn on the DMP.
2486           *  @return     0 if successful.
2487           */
2488          int mpu_set_dmp_state(unsigned char enable)
2489          {
2490   1          unsigned char tmp;
2491   1          if (st.chip_cfg.dmp_on == enable)
2492   1              return 0;
2493   1      
2494   1          if (enable) {
2495   2              if (!st.chip_cfg.dmp_loaded)
2496   2                  return -1;
2497   2              /* Disable dat ready interrupt. */
2498   2              set_int_enable(0);
2499   2              /* Disable bypass mode. */
2500   2              mpu_set_bypass(0);
2501   2              /* Keep constant sample rate, FIFO rate controlled by DMP. */
2502   2              mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
2503   2              /* Remove FIFO elements. */
2504   2              tmp = 0;
2505   2              i2c_write(st.hw->addr, 0x23, 1, &tmp);
2506   2              st.chip_cfg.dmp_on = 1;
2507   2              /* Enable DMP interrupt. */
2508   2              set_int_enable(1);
2509   2              mpu_reset_fifo();
2510   2          } else {
2511   2              /* Disable DMP interrupt. */
2512   2              set_int_enable(0);
2513   2              /* Restore FIFO settings. */
2514   2              tmp = st.chip_cfg.fifo_enable;
2515   2              i2c_write(st.hw->addr, 0x23, 1, &tmp);
2516   2              st.chip_cfg.dmp_on = 0;
2517   2              mpu_reset_fifo();
2518   2          }
2519   1          return 0;
2520   1      }
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 42  

2521          
2522          /**
2523           *  @brief      Get DMP state.
2524           *  @param[out] enabled 1 if enabled.
2525           *  @return     0 if successful.
2526           */
2527          int mpu_get_dmp_state(unsigned char *enabled)
2528          {
2529   1          enabled[0] = st.chip_cfg.dmp_on;
2530   1          return 0;
2531   1      }
2532          
2533          
2534          /* This initialization is similar to the one in ak8975.c. */
2535          //static int setup_compass(void)
2536          //{
2537          //#ifdef AK89xx_SECONDARY
2538          //    unsigned char dat[4], akm_addr;
2539          //
2540          //    mpu_set_bypass(1);
2541          //
2542          //    /* Find compass. Possible addresses range from 0x0C to 0x0F. */
2543          //    for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
2544          //        int result;
2545          //        result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, dat);
2546          //        if (!result && (dat[0] == AKM_WHOAMI))
2547          //            break;
2548          //    }
2549          //
2550          //    if (akm_addr > 0x0F) {
2551          //        /* TODO: Handle this case in all compass-related functions. */
2552          //        log_e("Compass not found.\n");
2553          //        return -1;
2554          //    }
2555          //
2556          //    st.chip_cfg.compass_addr = akm_addr;
2557          //
2558          //    dat[0] = AKM_POWER_DOWN;
2559          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, dat))
2560          //        return -1;
2561          //    delay_ms(1);
2562          //
2563          //    dat[0] = AKM_FUSE_ROM_ACCESS;
2564          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, dat))
2565          //        return -1;
2566          //    delay_ms(1);
2567          //
2568          //    /* Get sensitivity adjustment dat from fuse ROM. */
2569          //    if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, dat))
2570          //        return -1;
2571          //    st.chip_cfg.mag_sens_adj[0] = (long)dat[0] + 128;
2572          //    st.chip_cfg.mag_sens_adj[1] = (long)dat[1] + 128;
2573          //    st.chip_cfg.mag_sens_adj[2] = (long)dat[2] + 128;
2574          //
2575          //    dat[0] = AKM_POWER_DOWN;
2576          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, dat))
2577          //        return -1;
2578          //    delay_ms(1);
2579          //
2580          //    mpu_set_bypass(0);
2581          //
2582          //    /* Set up master mode, master clock, and ES bit. */
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 43  

2583          //    dat[0] = 0x40;
2584          //    if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, dat))
2585          //        return -1;
2586          //
2587          //    /* Slave 0 reads from AKM dat registers. */
2588          //    dat[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
2589          //    if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, dat))
2590          //        return -1;
2591          //
2592          //    /* Compass reads start at this register. */
2593          //    dat[0] = AKM_REG_ST1;
2594          //    if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, dat))
2595          //        return -1;
2596          //
2597          //    /* Enable slave 0, 8-byte reads. */
2598          //    dat[0] = BIT_SLAVE_EN | 8;
2599          //    if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, dat))
2600          //        return -1;
2601          //
2602          //    /* Slave 1 changes AKM measurement mode. */
2603          //    dat[0] = st.chip_cfg.compass_addr;
2604          //    if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, dat))
2605          //        return -1;
2606          //
2607          //    /* AKM measurement mode register. */
2608          //    dat[0] = AKM_REG_CNTL;
2609          //    if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, dat))
2610          //        return -1;
2611          //
2612          //    /* Enable slave 1, 1-byte writes. */
2613          //    dat[0] = BIT_SLAVE_EN | 1;
2614          //    if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, dat))
2615          //        return -1;
2616          //
2617          //    /* Set slave 1 dat. */
2618          //    dat[0] = AKM_SINGLE_MEASUREMENT;
2619          //    if (i2c_write(st.hw->addr, st.reg->s1_do, 1, dat))
2620          //        return -1;
2621          //
2622          //    /* Trigger slave 0 and slave 1 actions at each sample. */
2623          //    dat[0] = 0x03;
2624          //    if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, dat))
2625          //        return -1;
2626          //
2627          //#ifdef MPU9150
2628          //    /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
2629          //    dat[0] = BIT_I2C_MST_VDDIO;
2630          //    if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, dat))
2631          //        return -1;
2632          //#endif
2633          //
2634          //    return 0;
2635          //#else
2636          //    return -1;
2637          //#endif
2638          //}
2639          
2640          /**
2641           *  @brief      Read raw compass dat.
2642           *  @param[out] dat        Raw dat in hardware units.
2643           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
2644           *  @return     0 if successful.
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 44  

2645           */
2646          int mpu_get_compass_reg(short *dat, unsigned long *timestamp)
2647          {
2648   1      #ifdef AK89xx_SECONDARY
                  unsigned char tmp[9];
              
                  if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
                      return -1;
              
              #ifdef AK89xx_BYPASS
                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
                      return -1;
                  tmp[8] = AKM_SINGLE_MEASUREMENT;
                  if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
                      return -1;
              #else
                  if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
                      return -1;
              #endif
              
              #if defined AK8975_SECONDARY
                  /* AK8975 doesn't have the overrun error bit. */
                  if (!(tmp[0] & AKM_dat_READY))
                      return -2;
                  if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_dat_ERROR))
                      return -3;
              #elif defined AK8963_SECONDARY
                  /* AK8963 doesn't have the dat read error bit. */
                  if (!(tmp[0] & AKM_dat_READY) || (tmp[0] & AKM_dat_OVERRUN))
                      return -2;
                  if (tmp[7] & AKM_OVERFLOW)
                      return -3;
              #endif
                  dat[0] = (tmp[2] << 8) | tmp[1];
                  dat[1] = (tmp[4] << 8) | tmp[3];
                  dat[2] = (tmp[6] << 8) | tmp[5];
              
                  dat[0] = ((long)dat[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
                  dat[1] = ((long)dat[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
                  dat[2] = ((long)dat[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
              
                  if (timestamp)
                      get_ms(timestamp);
                  return 0;
              #else
2690   1          return -1;
2691   1      #endif
2692   1      }
2693          
2694          /**
2695           *  @brief      Get the compass full-scale range.
2696           *  @param[out] fsr Current full-scale range.
2697           *  @return     0 if successful.
2698           */
2699          int mpu_get_compass_fsr(unsigned short *fsr)
2700          {
2701   1      #ifdef AK89xx_SECONDARY
                  fsr[0] = st.hw->compass_fsr;
                  return 0;
              #else
2705   1          return -1;
2706   1      #endif
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 45  

2707   1      }
2708          
2709          /**
2710           *  @brief      Enters LP accel motion interrupt mode.
2711           *  The behavior of this feature is very different between the MPU6050 and the
2712           *  MPU6500. Each chip's version of this feature is explained below.
2713           *
2714           *  \n MPU6050:
2715           *  \n When this mode is first enabled, the hardware captures a single accel
2716           *  sample, and subsequent samples are compared with this one to determine if
2717           *  the device is in motion. Therefore, whenever this "locked" sample needs to
2718           *  be changed, this function must be called again.
2719           *
2720           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
2721           *  increments.
2722           *
2723           *  \n Low-power accel mode supports the following frequencies:
2724           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
2725           *
2726           *  \n MPU6500:
2727           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
2728           *  sample. The hardware monitors the accel dat and detects any large change
2729           *  over a short period of time.
2730           *
2731           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
2732           *  increments.
2733           *
2734           *  \n MPU6500 Low-power accel mode supports the following frequencies:
2735           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
2736           *
2737           *  \n\n NOTES:
2738           *  \n The driver will round down @e thresh to the nearest supported value if
2739           *  an unsupported threshold is selected.
2740           *  \n To select a fractional wake-up frequency, round down the value passed to
2741           *  @e lpa_freq.
2742           *  \n The MPU6500 does not support a delay parameter. If this function is used
2743           *  for the MPU6500, the value passed to @e time will be ignored.
2744           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
2745           *  the previous configuration.
2746           *
2747           *  @param[in]  thresh      Motion threshold in mg.
2748           *  @param[in]  time        Duration in milliseconds that the accel dat must
2749           *                          exceed @e thresh before motion is reported.
2750           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
2751           *  @return     0 if successful.
2752           */
2753          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
2754              unsigned char lpa_freq)
2755          {
2756   1          unsigned char dat[3];
2757   1      
2758   1          if (lpa_freq) {
2759   2              unsigned char thresh_hw;
2760   2      
2761   2      #if defined MPU6050
2762   2              /* TODO: Make these const/#defines. */
2763   2              /* 1LSb = 32mg. */
2764   2              if (thresh > 8160)
2765   2                  thresh_hw = 255;
2766   2              else if (thresh < 32)
2767   2                  thresh_hw = 1;
2768   2              else
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 46  

2769   2                  thresh_hw = thresh >> 5;
2770   2      #elif defined MPU6500
                      /* 1LSb = 4mg. */
                      if (thresh > 1020)
                          thresh_hw = 255;
                      else if (thresh < 4)
                          thresh_hw = 1;
                      else
                          thresh_hw = thresh >> 2;
              #endif
2779   2      
2780   2              if (!time)
2781   2                  /* Minimum duration must be 1ms. */
2782   2                  time = 1;
2783   2      
2784   2      #if defined MPU6050
2785   2              if (lpa_freq > 40)
2786   2      #elif defined MPU6500
                      if (lpa_freq > 640)
              #endif
2789   2                  /* At this point, the chip has not been re-configured, so the
2790   2                   * function can safely exit.
2791   2                   */
2792   2                  return -1;
2793   2      
2794   2              if (!st.chip_cfg.int_motion_only) {
2795   3                  /* Store current settings for later. */
2796   3                  if (st.chip_cfg.dmp_on) {
2797   4                      mpu_set_dmp_state(0);
2798   4                      st.chip_cfg.cache.dmp_on = 1;
2799   4                  } else
2800   3                      st.chip_cfg.cache.dmp_on = 0;
2801   3                  mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
2802   3                  mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
2803   3                  mpu_get_lpf(&st.chip_cfg.cache.lpf);
2804   3                  mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
2805   3                  st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
2806   3                  mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
2807   3              }
2808   2      
2809   2      #ifdef MPU6050
2810   2              /* Disable hardware interrupts for now. */
2811   2              set_int_enable(0);
2812   2      
2813   2              /* Enter full-power accel-only mode. */
2814   2              mpu_lp_accel_mode(0);
2815   2      
2816   2              /* Override current LPF (and HPF) settings to obtain a valid accel
2817   2               * reading.
2818   2               */
2819   2              dat[0] = INV_FILTER_256HZ_NOLPF2;
2820   2              if (i2c_write(st.hw->addr, st.reg->lpf, 1, dat))
2821   2                  return -1;
2822   2      
2823   2              /* NOTE: Digital high pass filter should be configured here. Since this
2824   2               * driver doesn't modify those bits anywhere, they should already be
2825   2               * cleared by default.
2826   2               */
2827   2      
2828   2              /* Configure the device to send motion interrupts. */
2829   2              /* Enable motion interrupt. */
2830   2              dat[0] = BIT_MOT_INT_EN;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 47  

2831   2              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, dat))
2832   2                  goto lp_int_restore;
2833   2      
2834   2              /* Set motion interrupt parameters. */
2835   2              dat[0] = thresh_hw;
2836   2              dat[1] = time;
2837   2              if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, dat))
2838   2                  goto lp_int_restore;
2839   2      
2840   2              /* Force hardware to "lock" current accel sample. */
2841   2              delay_ms(5);
2842   2              dat[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
2843   2              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, dat))
2844   2                  goto lp_int_restore;
2845   2      
2846   2              /* Set up LP accel mode. */
2847   2              dat[0] = BIT_LPA_CYCLE;
2848   2              if (lpa_freq == 1)
2849   2                  dat[1] = INV_LPA_1_25HZ;
2850   2              else if (lpa_freq <= 5)
2851   2                  dat[1] = INV_LPA_5HZ;
2852   2              else if (lpa_freq <= 20)
2853   2                  dat[1] = INV_LPA_20HZ;
2854   2              else
2855   2                  dat[1] = INV_LPA_40HZ;
2856   2              dat[1] = (dat[1] << 6) | BIT_STBY_XYZG;
2857   2              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, dat))
2858   2                  goto lp_int_restore;
2859   2      
2860   2              st.chip_cfg.int_motion_only = 1;
2861   2              return 0;
2862   2      #elif defined MPU6500
                      /* Disable hardware interrupts. */
                      set_int_enable(0);
              
                      /* Enter full-power accel-only mode, no FIFO/DMP. */
                      dat[0] = 0;
                      dat[1] = 0;
                      dat[2] = BIT_STBY_XYZG;
                      if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, dat))
                          goto lp_int_restore;
              
                      /* Set motion threshold. */
                      dat[0] = thresh_hw;
                      if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, dat))
                          goto lp_int_restore;
              
                      /* Set wake frequency. */
                      if (lpa_freq == 1)
                          dat[0] = INV_LPA_1_25HZ;
                      else if (lpa_freq == 2)
                          dat[0] = INV_LPA_2_5HZ;
                      else if (lpa_freq <= 5)
                          dat[0] = INV_LPA_5HZ;
                      else if (lpa_freq <= 10)
                          dat[0] = INV_LPA_10HZ;
                      else if (lpa_freq <= 20)
                          dat[0] = INV_LPA_20HZ;
                      else if (lpa_freq <= 40)
                          dat[0] = INV_LPA_40HZ;
                      else if (lpa_freq <= 80)
                          dat[0] = INV_LPA_80HZ;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 48  

                      else if (lpa_freq <= 160)
                          dat[0] = INV_LPA_160HZ;
                      else if (lpa_freq <= 320)
                          dat[0] = INV_LPA_320HZ;
                      else
                          dat[0] = INV_LPA_640HZ;
                      if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, dat))
                          goto lp_int_restore;
              
                      /* Enable motion interrupt (MPU6500 version). */
                      dat[0] = BITS_WOM_EN;
                      if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, dat))
                          goto lp_int_restore;
              
                      /* Enable cycle mode. */
                      dat[0] = BIT_LPA_CYCLE;
                      if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, dat))
                          goto lp_int_restore;
              
                      /* Enable interrupt. */
                      dat[0] = BIT_MOT_INT_EN;
                      if (i2c_write(st.hw->addr, st.reg->int_enable, 1, dat))
                          goto lp_int_restore;
              
                      st.chip_cfg.int_motion_only = 1;
                      return 0;
              #endif
2920   2          } else {
2921   2              /* Don't "restore" the previous state if no state has been saved. */
2922   2              int ii;
2923   2              char *cache_ptr = (char*)&st.chip_cfg.cache;
2924   2              for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
2925   3                  if (cache_ptr[ii] != 0)
2926   3                      goto lp_int_restore;
2927   3              }
2928   2              /* If we reach this point, motion interrupt mode hasn't been used yet. */
2929   2              return -1;
2930   2          }
2931   1      lp_int_restore:
2932   1          /* Set to invalid values to ensure no I2C writes are skipped. */
2933   1          st.chip_cfg.gyro_fsr = 0xFF;
2934   1          st.chip_cfg.accel_fsr = 0xFF;
2935   1          st.chip_cfg.lpf = 0xFF;
2936   1          st.chip_cfg.sample_rate = 0xFFFF;
2937   1          st.chip_cfg.sensors = 0xFF;
2938   1          st.chip_cfg.fifo_enable = 0xFF;
2939   1          st.chip_cfg.clk_src = INV_CLK_PLL;
2940   1          mpu_set_sensors(st.chip_cfg.cache.sensors_on);
2941   1          mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
2942   1          mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
2943   1          mpu_set_lpf(st.chip_cfg.cache.lpf);
2944   1          mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
2945   1          mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
2946   1      
2947   1          if (st.chip_cfg.cache.dmp_on)
2948   1              mpu_set_dmp_state(1);
2949   1      
2950   1      #ifdef MPU6500
                  /* Disable motion interrupt (MPU6500 version). */
                  dat[0] = 0;
                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, dat))
                      goto lp_int_restore;
C51 COMPILER V9.00   INV_MPU                                                               07/16/2014 23:47:59 PAGE 49  

              #endif
2956   1      
2957   1          st.chip_cfg.int_motion_only = 0;
2958   1          return 0;
2959   1      }
2960          
2961          /**
2962           *  @}
2963           */
2964          

C51 COMPILATION COMPLETE.  7 WARNING(S),  7 ERROR(S)
