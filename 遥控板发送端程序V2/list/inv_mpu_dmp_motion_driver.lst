C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE INV_MPU_DMP_MOTION_DRIVER
OBJECT MODULE PLACED IN .\obj\inv_mpu_dmp_motion_driver.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\inv_mpu_dmp_motion_driver.c LARGE BROWSE ORDER INCDIR(.\inc) DEBUG OBJE
                    -CTEXTEND PRINT(.\list\inv_mpu_dmp_motion_driver.lst) TABS(2) OBJECT(.\obj\inv_mpu_dmp_motion_driver.obj)

line level    source

   1          /*
   2           $License:
   3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
   4              See included License.txt for License information.
   5           $
   6           */
   7          /**
   8           *  @addtogroup  DRIVERS Sensor Driver Layer
   9           *  @brief       Hardware drivers to communicate with sensors via I2C.
  10           *
  11           *  @{
  12           *      @file       inv_mpu_dmp_motion_driver.c
  13           *      @brief      DMP image and interface functions.
  14           *      @details    All functions are preceded by the dmp_ prefix to
  15           *                  differentiate among MPL and general driver function calls.
  16           */
  17          #include <stdio.h>
  18          #include <stdint.h>
*** ERROR C320 IN LINE 33 OF .\INC\STDINT.H: "Use this header only with Microsoft Visual C++ compilers!"
*** WARNING C322 IN LINE 39 OF .\INC\STDINT.H: unknown identifier
*** WARNING C322 IN LINE 48 OF .\INC\STDINT.H: unknown identifier
*** WARNING C318 IN LINE 51 OF .\INC\STDINT.H: can't open file 'wchar.h'
*** WARNING C322 IN LINE 52 OF .\INC\STDINT.H: unknown identifier
*** ERROR C129 IN LINE 69 OF .\INC\STDINT.H: missing ';' before 'int8_t'
  19          #include <stdlib.h>
  20          #include <string.h>
  21          #include <math.h>
  22          #include "inv_mpu.h"
  23          #include "inv_mpu_dmp_motion_driver.h"
  24          #include "dmpKey.h"
  25          #include "dmpmap.h"
  26          #include "Time.h"
*** WARNING C318 IN LINE 26 OF src\inv_mpu_dmp_motion_driver.c: can't open file 'Time.h'
  27          #include "delay.h"
  28          
  29          #define  MOTION_DRIVER_TARGET_MSP430
  30          /* The following functions must be defined for this platform:
  31           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
  32           *      unsigned char length, unsigned char const *data)
  33           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
  34           *      unsigned char length, unsigned char *data)
  35           * delay_ms(unsigned long num_ms)
  36           * get_ms(unsigned long *count)
  37           */
  38          #if defined MOTION_DRIVER_TARGET_MSP430
  39          //#include "msp430.h"
  40          //#include "msp430_clock.h"
  41          #define delay_ms    delay_ms
  42          #define get_ms      get_ms
  43          #define log_i(...)     do {} while (0)
*** ERROR C301 IN LINE 43 OF src\inv_mpu_dmp_motion_driver.c: identifier expected
*** ERROR C304 IN LINE 43 OF src\inv_mpu_dmp_motion_driver.c: bad macro parameter list
  44          #define log_e(...)     do {} while (0)
*** ERROR C301 IN LINE 44 OF src\inv_mpu_dmp_motion_driver.c: identifier expected
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 2   

*** ERROR C304 IN LINE 44 OF src\inv_mpu_dmp_motion_driver.c: bad macro parameter list
  45          
  46          #elif defined EMPL_TARGET_MSP430
              #include "msp430.h"
              #include "msp430_clock.h"
              #include "log.h"
              #define delay_ms    msp430_delay_ms
              #define get_ms      msp430_get_clock_ms
              #define log_i       MPL_LOGI
              #define log_e       MPL_LOGE
              
              #elif defined EMPL_TARGET_UC3L0
              /* Instead of using the standard TWI driver from the ASF library, we're using
               * a TWI driver that follows the slave address + register address convention.
               */
              #include "delay.h"
              #include "sysclk.h"
              #include "log.h"
              #include "uc3l0_clock.h"
              /* delay_ms is a function already defined in ASF. */
              #define get_ms  uc3l0_get_clock_ms
              #define log_i       MPL_LOGI
              #define log_e       MPL_LOGE
              
              #else
              //#error  Gyro driver is missing the system layer implementations.
              #endif
  71          
  72          /* These defines are copied from dmpDefaultMPU6050.c in the general MPL
  73           * releases. These defines may change for each DMP image, so be sure to modify
  74           * these values when switching to a new image.
  75           */
  76          #define CFG_LP_QUAT             (2712)
  77          #define END_ORIENT_TEMP         (1866)
  78          #define CFG_27                  (2742)
  79          #define CFG_20                  (2224)
  80          #define CFG_23                  (2745)
  81          #define CFG_FIFO_ON_EVENT       (2690)
  82          #define END_PREDICTION_UPDATE   (1761)
  83          #define CGNOTICE_INTR           (2620)
  84          #define X_GRT_Y_TMP             (1358)
  85          #define CFG_DR_INT              (1029)
  86          #define CFG_AUTH                (1035)
  87          #define UPDATE_PROP_ROT         (1835)
  88          #define END_COMPARE_Y_X_TMP2    (1455)
  89          #define SKIP_X_GRT_Y_TMP        (1359)
  90          #define SKIP_END_COMPARE        (1435)
  91          #define FCFG_3                  (1088)
  92          #define FCFG_2                  (1066)
  93          #define FCFG_1                  (1062)
  94          #define END_COMPARE_Y_X_TMP3    (1434)
  95          #define FCFG_7                  (1073)
  96          #define FCFG_6                  (1106)
  97          #define FLAT_STATE_END          (1713)
  98          #define SWING_END_4             (1616)
  99          #define SWING_END_2             (1565)
 100          #define SWING_END_3             (1587)
 101          #define SWING_END_1             (1550)
 102          #define CFG_8                   (2718)
 103          #define CFG_15                  (2727)
 104          #define CFG_16                  (2746)
 105          #define CFG_EXT_GYRO_BIAS       (1189)
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 3   

 106          #define END_COMPARE_Y_X_TMP     (1407)
 107          #define DO_NOT_UPDATE_PROP_ROT  (1839)
 108          #define CFG_7                   (1205)
 109          #define FLAT_STATE_END_TEMP     (1683)
 110          #define END_COMPARE_Y_X         (1484)
 111          #define SKIP_SWING_END_1        (1551)
 112          #define SKIP_SWING_END_3        (1588)
 113          #define SKIP_SWING_END_2        (1566)
 114          #define TILTG75_START           (1672)
 115          #define CFG_6                   (2753)
 116          #define TILTL75_END             (1669)
 117          #define END_ORIENT              (1884)
 118          #define CFG_FLICK_IN            (2573)
 119          #define TILTL75_START           (1643)
 120          #define CFG_MOTION_BIAS         (1208)
 121          #define X_GRT_Y                 (1408)
 122          #define TEMPLABEL               (2324)
 123          #define CFG_ANDROID_ORIENT_INT  (1853)
 124          #define CFG_GYRO_RAW_DATA       (2722)
 125          #define X_GRT_Y_TMP2            (1379)
 126          
 127          #define D_0_22                  (22+512)
 128          #define D_0_24                  (24+512)
 129          
 130          #define D_0_36                  (36)
 131          #define D_0_52                  (52)
 132          #define D_0_96                  (96)
 133          #define D_0_104                 (104)
 134          #define D_0_108                 (108)
 135          #define D_0_163                 (163)
 136          #define D_0_188                 (188)
 137          #define D_0_192                 (192)
 138          #define D_0_224                 (224)
 139          #define D_0_228                 (228)
 140          #define D_0_232                 (232)
 141          #define D_0_236                 (236)
 142          
 143          #define D_1_2                   (256 + 2)
 144          #define D_1_4                   (256 + 4)
 145          #define D_1_8                   (256 + 8)
 146          #define D_1_10                  (256 + 10)
 147          #define D_1_24                  (256 + 24)
 148          #define D_1_28                  (256 + 28)
 149          #define D_1_36                  (256 + 36)
 150          #define D_1_40                  (256 + 40)
 151          #define D_1_44                  (256 + 44)
 152          #define D_1_72                  (256 + 72)
 153          #define D_1_74                  (256 + 74)
 154          #define D_1_79                  (256 + 79)
 155          #define D_1_88                  (256 + 88)
 156          #define D_1_90                  (256 + 90)
 157          #define D_1_92                  (256 + 92)
 158          #define D_1_96                  (256 + 96)
 159          #define D_1_98                  (256 + 98)
 160          #define D_1_106                 (256 + 106)
 161          #define D_1_108                 (256 + 108)
 162          #define D_1_112                 (256 + 112)
 163          #define D_1_128                 (256 + 144)
 164          #define D_1_152                 (256 + 12)
 165          #define D_1_160                 (256 + 160)
 166          #define D_1_176                 (256 + 176)
 167          #define D_1_178                 (256 + 178)
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 4   

 168          #define D_1_218                 (256 + 218)
 169          #define D_1_232                 (256 + 232)
 170          #define D_1_236                 (256 + 236)
 171          #define D_1_240                 (256 + 240)
 172          #define D_1_244                 (256 + 244)
 173          #define D_1_250                 (256 + 250)
 174          #define D_1_252                 (256 + 252)
 175          #define D_2_12                  (512 + 12)
 176          #define D_2_96                  (512 + 96)
 177          #define D_2_108                 (512 + 108)
 178          #define D_2_208                 (512 + 208)
 179          #define D_2_224                 (512 + 224)
 180          #define D_2_236                 (512 + 236)
 181          #define D_2_244                 (512 + 244)
 182          #define D_2_248                 (512 + 248)
 183          #define D_2_252                 (512 + 252)
 184          
 185          #define CPASS_BIAS_X            (35 * 16 + 4)
 186          #define CPASS_BIAS_Y            (35 * 16 + 8)
 187          #define CPASS_BIAS_Z            (35 * 16 + 12)
 188          #define CPASS_MTX_00            (36 * 16)
 189          #define CPASS_MTX_01            (36 * 16 + 4)
 190          #define CPASS_MTX_02            (36 * 16 + 8)
 191          #define CPASS_MTX_10            (36 * 16 + 12)
 192          #define CPASS_MTX_11            (37 * 16)
 193          #define CPASS_MTX_12            (37 * 16 + 4)
 194          #define CPASS_MTX_20            (37 * 16 + 8)
 195          #define CPASS_MTX_21            (37 * 16 + 12)
 196          #define CPASS_MTX_22            (43 * 16 + 12)
 197          #define D_EXT_GYRO_BIAS_X       (61 * 16)
 198          #define D_EXT_GYRO_BIAS_Y       (61 * 16) + 4
 199          #define D_EXT_GYRO_BIAS_Z       (61 * 16) + 8
 200          #define D_ACT0                  (40 * 16)
 201          #define D_ACSX                  (40 * 16 + 4)
 202          #define D_ACSY                  (40 * 16 + 8)
 203          #define D_ACSZ                  (40 * 16 + 12)
 204          
 205          #define FLICK_MSG               (45 * 16 + 4)
 206          #define FLICK_COUNTER           (45 * 16 + 8)
 207          #define FLICK_LOWER             (45 * 16 + 12)
 208          #define FLICK_UPPER             (46 * 16 + 12)
 209          
 210          #define D_AUTH_OUT              (992)
 211          #define D_AUTH_IN               (996)
 212          #define D_AUTH_A                (1000)
 213          #define D_AUTH_B                (1004)
 214          
 215          #define D_PEDSTD_BP_B           (768 + 0x1C)
 216          #define D_PEDSTD_HP_A           (768 + 0x78)
 217          #define D_PEDSTD_HP_B           (768 + 0x7C)
 218          #define D_PEDSTD_BP_A4          (768 + 0x40)
 219          #define D_PEDSTD_BP_A3          (768 + 0x44)
 220          #define D_PEDSTD_BP_A2          (768 + 0x48)
 221          #define D_PEDSTD_BP_A1          (768 + 0x4C)
 222          #define D_PEDSTD_INT_THRSH      (768 + 0x68)
 223          #define D_PEDSTD_CLIP           (768 + 0x6C)
 224          #define D_PEDSTD_SB             (768 + 0x28)
 225          #define D_PEDSTD_SB_TIME        (768 + 0x2C)
 226          #define D_PEDSTD_PEAKTHRSH      (768 + 0x98)
 227          #define D_PEDSTD_TIML           (768 + 0x2A)
 228          #define D_PEDSTD_TIMH           (768 + 0x2E)
 229          #define D_PEDSTD_PEAK           (768 + 0X94)
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 5   

 230          #define D_PEDSTD_STEPCTR        (768 + 0x60)
 231          #define D_PEDSTD_TIMECTR        (964)
 232          #define D_PEDSTD_DECI           (768 + 0xA0)
 233          
 234          #define D_HOST_NO_MOT           (976)
 235          #define D_ACCEL_BIAS            (660)
 236          
 237          #define D_ORIENT_GAP            (76)
 238          
 239          #define D_TILT0_H               (48)
 240          #define D_TILT0_L               (50)
 241          #define D_TILT1_H               (52)
 242          #define D_TILT1_L               (54)
 243          #define D_TILT2_H               (56)
 244          #define D_TILT2_L               (58)
 245          #define D_TILT3_H               (60)
 246          #define D_TILT3_L               (62)
 247          
 248          #define DMP_CODE_SIZE           (3062)
 249          
 250          static const unsigned char dmp_memory[DMP_CODE_SIZE] = {
 251              /* bank # 0 */
 252              0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
 253              0x00, 0x65, 0x00, 0x54, 0xff, 0xef, 0x00, 0x00, 0xfa, 0x80, 0x00, 0x0b, 0x12, 0x82, 0x00, 0x01,
 254              0x03, 0x0c, 0x30, 0xc3, 0x0e, 0x8c, 0x8c, 0xe9, 0x14, 0xd5, 0x40, 0x02, 0x13, 0x71, 0x0f, 0x8e,
 255              0x38, 0x83, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83, 0x25, 0x8e, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83,
 256              0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xa9, 0xd6, 0x24, 0x00, 0x04, 0x00, 0x1a, 0x82, 0x79, 0xa1,
 257              0x00, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x83, 0x6f, 0xa2,
 258              0x00, 0x3e, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xca, 0xe3, 0x09, 0x3e, 0x80, 0x00, 0x00,
 259              0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
 260              0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x6e, 0x00, 0x00, 0x06, 0x92, 0x0a, 0x16, 0xc0, 0xdf,
 261              0xff, 0xff, 0x02, 0x56, 0xfd, 0x8c, 0xd3, 0x77, 0xff, 0xe1, 0xc4, 0x96, 0xe0, 0xc5, 0xbe, 0xaa,
 262              0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x2b, 0x00, 0x00, 0x16, 0x57, 0x00, 0x00, 0x03, 0x59,
 263              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xfa, 0x00, 0x02, 0x6c, 0x1d, 0x00, 0x00, 0x00, 0x00,
 264              0x3f, 0xff, 0xdf, 0xeb, 0x00, 0x3e, 0xb3, 0xb6, 0x00, 0x0d, 0x22, 0x78, 0x00, 0x00, 0x2f, 0x3c,
 265              0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x42, 0xb5, 0x00, 0x00, 0x39, 0xa2, 0x00, 0x00, 0xb3, 0x65,
 266              0xd9, 0x0e, 0x9f, 0xc9, 0x1d, 0xcf, 0x4c, 0x34, 0x30, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
 267              0x3b, 0xb6, 0x7a, 0xe8, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 268              /* bank # 1 */
 269              0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0xfa, 0x92, 0x10, 0x00, 0x22, 0x5e, 0x00, 0x0d, 0x22, 0x9f,
 270              0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0xff, 0x46, 0x00, 0x00, 0x63, 0xd4, 0x00, 0x00,
 271              0x10, 0x00, 0x00, 0x00, 0x04, 0xd6, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00,
 272              0x00, 0x00, 0x10, 0x72, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 273              0x00, 0x06, 0x00, 0x02, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
 274              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x64, 0x00, 0x20, 0x00, 0x00,
 275              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00,
 276              0x00, 0x00, 0x00, 0x32, 0xf8, 0x98, 0x00, 0x00, 0xff, 0x65, 0x00, 0x00, 0x83, 0x0f, 0x00, 0x00,
 277              0xff, 0x9b, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 278              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 279              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
 280              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xb2, 0x6a, 0x00, 0x02, 0x00, 0x00,
 281              0x00, 0x01, 0xfb, 0x83, 0x00, 0x68, 0x00, 0x00, 0x00, 0xd9, 0xfc, 0x00, 0x7c, 0xf1, 0xff, 0x83,
 282              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x64, 0x03, 0xe8, 0x00, 0x64, 0x00, 0x28,
 283              0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x16, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
 284              0x00, 0x00, 0x10, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x10, 0x00,
 285              /* bank # 2 */
 286              0x00, 0x28, 0x00, 0x00, 0xff, 0xff, 0x45, 0x81, 0xff, 0xff, 0xfa, 0x72, 0x00, 0x00, 0x00, 0x00,
 287              0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0x05, 0xba, 0xc6, 0x00, 0x47, 0x78, 0xa2,
 288              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
 289              0x00, 0x00, 0x25, 0x4d, 0x00, 0x2f, 0x70, 0x6d, 0x00, 0x00, 0x05, 0xae, 0x00, 0x0c, 0x02, 0xd0,
 290              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 291              0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 6   

 292              0x00, 0x64, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 293              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 294              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 295              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 296              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 297              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 298              0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e,
 299              0x00, 0x00, 0x0a, 0xc7, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xff, 0xff, 0xff, 0x9c,
 300              0x00, 0x00, 0x0b, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64,
 301              0xff, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 302              /* bank # 3 */
 303              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 304              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x24, 0x26, 0xd3,
 305              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x96, 0x00, 0x3c,
 306              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 307              0x0c, 0x0a, 0x4e, 0x68, 0xcd, 0xcf, 0x77, 0x09, 0x50, 0x16, 0x67, 0x59, 0xc6, 0x19, 0xce, 0x82,
 308              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 309              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xd7, 0x84, 0x00, 0x03, 0x00, 0x00, 0x00,
 310              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x93, 0x8f, 0x9d, 0x1e, 0x1b, 0x1c, 0x19,
 311              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 312              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x18, 0x85, 0x00, 0x00, 0x40, 0x00,
 313              0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 314              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 315              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 316              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 317              0x00, 0x00, 0x00, 0x00, 0x67, 0x7d, 0xdf, 0x7e, 0x72, 0x90, 0x2e, 0x55, 0x4c, 0xf6, 0xe6, 0x88,
 318              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 319          
 320              /* bank # 4 */
 321              0xd8, 0xdc, 0xb4, 0xb8, 0xb0, 0xd8, 0xb9, 0xab, 0xf3, 0xf8, 0xfa, 0xb3, 0xb7, 0xbb, 0x8e, 0x9e,
 322              0xae, 0xf1, 0x32, 0xf5, 0x1b, 0xf1, 0xb4, 0xb8, 0xb0, 0x80, 0x97, 0xf1, 0xa9, 0xdf, 0xdf, 0xdf,
 323              0xaa, 0xdf, 0xdf, 0xdf, 0xf2, 0xaa, 0xc5, 0xcd, 0xc7, 0xa9, 0x0c, 0xc9, 0x2c, 0x97, 0xf1, 0xa9,
 324              0x89, 0x26, 0x46, 0x66, 0xb2, 0x89, 0x99, 0xa9, 0x2d, 0x55, 0x7d, 0xb0, 0xb0, 0x8a, 0xa8, 0x96,
 325              0x36, 0x56, 0x76, 0xf1, 0xba, 0xa3, 0xb4, 0xb2, 0x80, 0xc0, 0xb8, 0xa8, 0x97, 0x11, 0xb2, 0x83,
 326              0x98, 0xba, 0xa3, 0xf0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xb2, 0xb9, 0xb4, 0x98, 0x83, 0xf1,
 327              0xa3, 0x29, 0x55, 0x7d, 0xba, 0xb5, 0xb1, 0xa3, 0x83, 0x93, 0xf0, 0x00, 0x28, 0x50, 0xf5, 0xb2,
 328              0xb6, 0xaa, 0x83, 0x93, 0x28, 0x54, 0x7c, 0xf1, 0xb9, 0xa3, 0x82, 0x93, 0x61, 0xba, 0xa2, 0xda,
 329              0xde, 0xdf, 0xdb, 0x81, 0x9a, 0xb9, 0xae, 0xf5, 0x60, 0x68, 0x70, 0xf1, 0xda, 0xba, 0xa2, 0xdf,
 330              0xd9, 0xba, 0xa2, 0xfa, 0xb9, 0xa3, 0x82, 0x92, 0xdb, 0x31, 0xba, 0xa2, 0xd9, 0xba, 0xa2, 0xf8,
 331              0xdf, 0x85, 0xa4, 0xd0, 0xc1, 0xbb, 0xad, 0x83, 0xc2, 0xc5, 0xc7, 0xb8, 0xa2, 0xdf, 0xdf, 0xdf,
 332              0xba, 0xa0, 0xdf, 0xdf, 0xdf, 0xd8, 0xd8, 0xf1, 0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35,
 333              0x5d, 0xb2, 0xb6, 0xba, 0xaf, 0x8c, 0x96, 0x19, 0x8f, 0x9f, 0xa7, 0x0e, 0x16, 0x1e, 0xb4, 0x9a,
 334              0xb8, 0xaa, 0x87, 0x2c, 0x54, 0x7c, 0xba, 0xa4, 0xb0, 0x8a, 0xb6, 0x91, 0x32, 0x56, 0x76, 0xb2,
 335              0x84, 0x94, 0xa4, 0xc8, 0x08, 0xcd, 0xd8, 0xb8, 0xb4, 0xb0, 0xf1, 0x99, 0x82, 0xa8, 0x2d, 0x55,
 336              0x7d, 0x98, 0xa8, 0x0e, 0x16, 0x1e, 0xa2, 0x2c, 0x54, 0x7c, 0x92, 0xa4, 0xf0, 0x2c, 0x50, 0x78,
 337              /* bank # 5 */
 338              0xf1, 0x84, 0xa8, 0x98, 0xc4, 0xcd, 0xfc, 0xd8, 0x0d, 0xdb, 0xa8, 0xfc, 0x2d, 0xf3, 0xd9, 0xba,
 339              0xa6, 0xf8, 0xda, 0xba, 0xa6, 0xde, 0xd8, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xf3, 0xc8,
 340              0x41, 0xda, 0xa6, 0xc8, 0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0x82, 0xa8, 0x92, 0xf5, 0x2c, 0x54, 0x88,
 341              0x98, 0xf1, 0x35, 0xd9, 0xf4, 0x18, 0xd8, 0xf1, 0xa2, 0xd0, 0xf8, 0xf9, 0xa8, 0x84, 0xd9, 0xc7,
 342              0xdf, 0xf8, 0xf8, 0x83, 0xc5, 0xda, 0xdf, 0x69, 0xdf, 0x83, 0xc1, 0xd8, 0xf4, 0x01, 0x14, 0xf1,
 343              0xa8, 0x82, 0x4e, 0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x28, 0x97, 0x88, 0xf1,
 344              0x09, 0xf4, 0x1c, 0x1c, 0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x29,
 345              0xf4, 0x0d, 0xd8, 0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc2, 0x03, 0xd8, 0xde, 0xdf, 0x1a,
 346              0xd8, 0xf1, 0xa2, 0xfa, 0xf9, 0xa8, 0x84, 0x98, 0xd9, 0xc7, 0xdf, 0xf8, 0xf8, 0xf8, 0x83, 0xc7,
 347              0xda, 0xdf, 0x69, 0xdf, 0xf8, 0x83, 0xc3, 0xd8, 0xf4, 0x01, 0x14, 0xf1, 0x98, 0xa8, 0x82, 0x2e,
 348              0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x50, 0x97, 0x88, 0xf1, 0x09, 0xf4, 0x1c,
 349              0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf8, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x49, 0xf4, 0x0d, 0xd8,
 350              0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc4, 0x03, 0xd8, 0xde, 0xdf, 0xd8, 0xf1, 0xad, 0x88,
 351              0x98, 0xcc, 0xa8, 0x09, 0xf9, 0xd9, 0x82, 0x92, 0xa8, 0xf5, 0x7c, 0xf1, 0x88, 0x3a, 0xcf, 0x94,
 352              0x4a, 0x6e, 0x98, 0xdb, 0x69, 0x31, 0xda, 0xad, 0xf2, 0xde, 0xf9, 0xd8, 0x87, 0x95, 0xa8, 0xf2,
 353              0x21, 0xd1, 0xda, 0xa5, 0xf9, 0xf4, 0x17, 0xd9, 0xf1, 0xae, 0x8e, 0xd0, 0xc0, 0xc3, 0xae, 0x82,
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 7   

 354              /* bank # 6 */
 355              0xc6, 0x84, 0xc3, 0xa8, 0x85, 0x95, 0xc8, 0xa5, 0x88, 0xf2, 0xc0, 0xf1, 0xf4, 0x01, 0x0e, 0xf1,
 356              0x8e, 0x9e, 0xa8, 0xc6, 0x3e, 0x56, 0xf5, 0x54, 0xf1, 0x88, 0x72, 0xf4, 0x01, 0x15, 0xf1, 0x98,
 357              0x45, 0x85, 0x6e, 0xf5, 0x8e, 0x9e, 0x04, 0x88, 0xf1, 0x42, 0x98, 0x5a, 0x8e, 0x9e, 0x06, 0x88,
 358              0x69, 0xf4, 0x01, 0x1c, 0xf1, 0x98, 0x1e, 0x11, 0x08, 0xd0, 0xf5, 0x04, 0xf1, 0x1e, 0x97, 0x02,
 359              0x02, 0x98, 0x36, 0x25, 0xdb, 0xf9, 0xd9, 0x85, 0xa5, 0xf3, 0xc1, 0xda, 0x85, 0xa5, 0xf3, 0xdf,
 360              0xd8, 0x85, 0x95, 0xa8, 0xf3, 0x09, 0xda, 0xa5, 0xfa, 0xd8, 0x82, 0x92, 0xa8, 0xf5, 0x78, 0xf1,
 361              0x88, 0x1a, 0x84, 0x9f, 0x26, 0x88, 0x98, 0x21, 0xda, 0xf4, 0x1d, 0xf3, 0xd8, 0x87, 0x9f, 0x39,
 362              0xd1, 0xaf, 0xd9, 0xdf, 0xdf, 0xfb, 0xf9, 0xf4, 0x0c, 0xf3, 0xd8, 0xfa, 0xd0, 0xf8, 0xda, 0xf9,
 363              0xf9, 0xd0, 0xdf, 0xd9, 0xf9, 0xd8, 0xf4, 0x0b, 0xd8, 0xf3, 0x87, 0x9f, 0x39, 0xd1, 0xaf, 0xd9,
 364              0xdf, 0xdf, 0xf4, 0x1d, 0xf3, 0xd8, 0xfa, 0xfc, 0xa8, 0x69, 0xf9, 0xf9, 0xaf, 0xd0, 0xda, 0xde,
 365              0xfa, 0xd9, 0xf8, 0x8f, 0x9f, 0xa8, 0xf1, 0xcc, 0xf3, 0x98, 0xdb, 0x45, 0xd9, 0xaf, 0xdf, 0xd0,
 366              0xf8, 0xd8, 0xf1, 0x8f, 0x9f, 0xa8, 0xca, 0xf3, 0x88, 0x09, 0xda, 0xaf, 0x8f, 0xcb, 0xf8, 0xd8,
 367              0xf2, 0xad, 0x97, 0x8d, 0x0c, 0xd9, 0xa5, 0xdf, 0xf9, 0xba, 0xa6, 0xf3, 0xfa, 0xf4, 0x12, 0xf2,
 368              0xd8, 0x95, 0x0d, 0xd1, 0xd9, 0xba, 0xa6, 0xf3, 0xfa, 0xda, 0xa5, 0xf2, 0xc1, 0xba, 0xa6, 0xf3,
 369              0xdf, 0xd8, 0xf1, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xca, 0xf3, 0x49, 0xda, 0xa6, 0xcb,
 370              0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0xd8, 0xad, 0x84, 0xf2, 0xc0, 0xdf, 0xf1, 0x8f, 0xcb, 0xc3, 0xa8,
 371              /* bank # 7 */
 372              0xb2, 0xb6, 0x86, 0x96, 0xc8, 0xc1, 0xcb, 0xc3, 0xf3, 0xb0, 0xb4, 0x88, 0x98, 0xa8, 0x21, 0xdb,
 373              0x71, 0x8d, 0x9d, 0x71, 0x85, 0x95, 0x21, 0xd9, 0xad, 0xf2, 0xfa, 0xd8, 0x85, 0x97, 0xa8, 0x28,
 374              0xd9, 0xf4, 0x08, 0xd8, 0xf2, 0x8d, 0x29, 0xda, 0xf4, 0x05, 0xd9, 0xf2, 0x85, 0xa4, 0xc2, 0xf2,
 375              0xd8, 0xa8, 0x8d, 0x94, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xf2, 0xd8, 0x87, 0x21, 0xd8, 0xf4, 0x0a,
 376              0xd8, 0xf2, 0x84, 0x98, 0xa8, 0xc8, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xd8, 0xf3, 0xa4, 0xc8, 0xbb,
 377              0xaf, 0xd0, 0xf2, 0xde, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xd8, 0xf1, 0xb8, 0xf6,
 378              0xb5, 0xb9, 0xb0, 0x8a, 0x95, 0xa3, 0xde, 0x3c, 0xa3, 0xd9, 0xf8, 0xd8, 0x5c, 0xa3, 0xd9, 0xf8,
 379              0xd8, 0x7c, 0xa3, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa5, 0xd9, 0xdf, 0xda, 0xfa, 0xd8, 0xb1,
 380              0x85, 0x30, 0xf7, 0xd9, 0xde, 0xd8, 0xf8, 0x30, 0xad, 0xda, 0xde, 0xd8, 0xf2, 0xb4, 0x8c, 0x99,
 381              0xa3, 0x2d, 0x55, 0x7d, 0xa0, 0x83, 0xdf, 0xdf, 0xdf, 0xb5, 0x91, 0xa0, 0xf6, 0x29, 0xd9, 0xfb,
 382              0xd8, 0xa0, 0xfc, 0x29, 0xd9, 0xfa, 0xd8, 0xa0, 0xd0, 0x51, 0xd9, 0xf8, 0xd8, 0xfc, 0x51, 0xd9,
 383              0xf9, 0xd8, 0x79, 0xd9, 0xfb, 0xd8, 0xa0, 0xd0, 0xfc, 0x79, 0xd9, 0xfa, 0xd8, 0xa1, 0xf9, 0xf9,
 384              0xf9, 0xf9, 0xf9, 0xa0, 0xda, 0xdf, 0xdf, 0xdf, 0xd8, 0xa1, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xac,
 385              0xde, 0xf8, 0xad, 0xde, 0x83, 0x93, 0xac, 0x2c, 0x54, 0x7c, 0xf1, 0xa8, 0xdf, 0xdf, 0xdf, 0xf6,
 386              0x9d, 0x2c, 0xda, 0xa0, 0xdf, 0xd9, 0xfa, 0xdb, 0x2d, 0xf8, 0xd8, 0xa8, 0x50, 0xda, 0xa0, 0xd0,
 387              0xde, 0xd9, 0xd0, 0xf8, 0xf8, 0xf8, 0xdb, 0x55, 0xf8, 0xd8, 0xa8, 0x78, 0xda, 0xa0, 0xd0, 0xdf,
 388              /* bank # 8 */
 389              0xd9, 0xd0, 0xfa, 0xf8, 0xf8, 0xf8, 0xf8, 0xdb, 0x7d, 0xf8, 0xd8, 0x9c, 0xa8, 0x8c, 0xf5, 0x30,
 390              0xdb, 0x38, 0xd9, 0xd0, 0xde, 0xdf, 0xa0, 0xd0, 0xde, 0xdf, 0xd8, 0xa8, 0x48, 0xdb, 0x58, 0xd9,
 391              0xdf, 0xd0, 0xde, 0xa0, 0xdf, 0xd0, 0xde, 0xd8, 0xa8, 0x68, 0xdb, 0x70, 0xd9, 0xdf, 0xdf, 0xa0,
 392              0xdf, 0xdf, 0xd8, 0xf1, 0xa8, 0x88, 0x90, 0x2c, 0x54, 0x7c, 0x98, 0xa8, 0xd0, 0x5c, 0x38, 0xd1,
 393              0xda, 0xf2, 0xae, 0x8c, 0xdf, 0xf9, 0xd8, 0xb0, 0x87, 0xa8, 0xc1, 0xc1, 0xb1, 0x88, 0xa8, 0xc6,
 394              0xf9, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8,
 395              0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xf7, 0x8d, 0x9d, 0xad, 0xf8, 0x18, 0xda,
 396              0xf2, 0xae, 0xdf, 0xd8, 0xf7, 0xad, 0xfa, 0x30, 0xd9, 0xa4, 0xde, 0xf9, 0xd8, 0xf2, 0xae, 0xde,
 397              0xfa, 0xf9, 0x83, 0xa7, 0xd9, 0xc3, 0xc5, 0xc7, 0xf1, 0x88, 0x9b, 0xa7, 0x7a, 0xad, 0xf7, 0xde,
 398              0xdf, 0xa4, 0xf8, 0x84, 0x94, 0x08, 0xa7, 0x97, 0xf3, 0x00, 0xae, 0xf2, 0x98, 0x19, 0xa4, 0x88,
 399              0xc6, 0xa3, 0x94, 0x88, 0xf6, 0x32, 0xdf, 0xf2, 0x83, 0x93, 0xdb, 0x09, 0xd9, 0xf2, 0xaa, 0xdf,
 400              0xd8, 0xd8, 0xae, 0xf8, 0xf9, 0xd1, 0xda, 0xf3, 0xa4, 0xde, 0xa7, 0xf1, 0x88, 0x9b, 0x7a, 0xd8,
 401              0xf3, 0x84, 0x94, 0xae, 0x19, 0xf9, 0xda, 0xaa, 0xf1, 0xdf, 0xd8, 0xa8, 0x81, 0xc0, 0xc3, 0xc5,
 402              0xc7, 0xa3, 0x92, 0x83, 0xf6, 0x28, 0xad, 0xde, 0xd9, 0xf8, 0xd8, 0xa3, 0x50, 0xad, 0xd9, 0xf8,
 403              0xd8, 0xa3, 0x78, 0xad, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa1, 0xda, 0xde, 0xc3, 0xc5, 0xc7,
 404              0xd8, 0xa1, 0x81, 0x94, 0xf8, 0x18, 0xf2, 0xb0, 0x89, 0xac, 0xc3, 0xc5, 0xc7, 0xf1, 0xd8, 0xb8,
 405              /* bank # 9 */
 406              0xb4, 0xb0, 0x97, 0x86, 0xa8, 0x31, 0x9b, 0x06, 0x99, 0x07, 0xab, 0x97, 0x28, 0x88, 0x9b, 0xf0,
 407              0x0c, 0x20, 0x14, 0x40, 0xb0, 0xb4, 0xb8, 0xf0, 0xa8, 0x8a, 0x9a, 0x28, 0x50, 0x78, 0xb7, 0x9b,
 408              0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xf1, 0xbb, 0xab,
 409              0x88, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0xb3, 0x8b, 0xb8, 0xa8, 0x04, 0x28, 0x50, 0x78, 0xf1, 0xb0,
 410              0x88, 0xb4, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xbb, 0xab, 0xb3, 0x8b, 0x02, 0x26, 0x46, 0x66, 0xb0,
 411              0xb8, 0xf0, 0x8a, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x8b, 0x29, 0x51, 0x79, 0x8a, 0x24, 0x70, 0x59,
 412              0x8b, 0x20, 0x58, 0x71, 0x8a, 0x44, 0x69, 0x38, 0x8b, 0x39, 0x40, 0x68, 0x8a, 0x64, 0x48, 0x31,
 413              0x8b, 0x30, 0x49, 0x60, 0x88, 0xf1, 0xac, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0x8c, 0xa8, 0x04, 0x28,
 414              0x50, 0x78, 0xf1, 0x88, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xac, 0x8c, 0x02, 0x26, 0x46, 0x66, 0xf0,
 415              0x89, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xa9,
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 8   

 416              0x88, 0x09, 0x20, 0x59, 0x70, 0xab, 0x11, 0x38, 0x40, 0x69, 0xa8, 0x19, 0x31, 0x48, 0x60, 0x8c,
 417              0xa8, 0x3c, 0x41, 0x5c, 0x20, 0x7c, 0x00, 0xf1, 0x87, 0x98, 0x19, 0x86, 0xa8, 0x6e, 0x76, 0x7e,
 418              0xa9, 0x99, 0x88, 0x2d, 0x55, 0x7d, 0xd8, 0xb1, 0xb5, 0xb9, 0xa3, 0xdf, 0xdf, 0xdf, 0xae, 0xd0,
 419              0xdf, 0xaa, 0xd0, 0xde, 0xf2, 0xab, 0xf8, 0xf9, 0xd9, 0xb0, 0x87, 0xc4, 0xaa, 0xf1, 0xdf, 0xdf,
 420              0xbb, 0xaf, 0xdf, 0xdf, 0xb9, 0xd8, 0xb1, 0xf1, 0xa3, 0x97, 0x8e, 0x60, 0xdf, 0xb0, 0x84, 0xf2,
 421              0xc8, 0xf8, 0xf9, 0xd9, 0xde, 0xd8, 0x93, 0x85, 0xf1, 0x4a, 0xb1, 0x83, 0xa3, 0x08, 0xb5, 0x83,
 422              /* bank # 10 */
 423              0x9a, 0x08, 0x10, 0xb7, 0x9f, 0x10, 0xd8, 0xf1, 0xb0, 0xba, 0xae, 0xb0, 0x8a, 0xc2, 0xb2, 0xb6,
 424              0x8e, 0x9e, 0xf1, 0xfb, 0xd9, 0xf4, 0x1d, 0xd8, 0xf9, 0xd9, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad,
 425              0x61, 0xd9, 0xae, 0xfb, 0xd8, 0xf4, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad, 0x19, 0xd9, 0xae, 0xfb,
 426              0xdf, 0xd8, 0xf4, 0x16, 0xf1, 0xd8, 0xf8, 0xad, 0x8d, 0x61, 0xd9, 0xf4, 0xf4, 0xac, 0xf5, 0x9c,
 427              0x9c, 0x8d, 0xdf, 0x2b, 0xba, 0xb6, 0xae, 0xfa, 0xf8, 0xf4, 0x0b, 0xd8, 0xf1, 0xae, 0xd0, 0xf8,
 428              0xad, 0x51, 0xda, 0xae, 0xfa, 0xf8, 0xf1, 0xd8, 0xb9, 0xb1, 0xb6, 0xa3, 0x83, 0x9c, 0x08, 0xb9,
 429              0xb1, 0x83, 0x9a, 0xb5, 0xaa, 0xc0, 0xfd, 0x30, 0x83, 0xb7, 0x9f, 0x10, 0xb5, 0x8b, 0x93, 0xf2,
 430              0x02, 0x02, 0xd1, 0xab, 0xda, 0xde, 0xd8, 0xf1, 0xb0, 0x80, 0xba, 0xab, 0xc0, 0xc3, 0xb2, 0x84,
 431              0xc1, 0xc3, 0xd8, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0x09, 0xb4, 0xd9, 0xab, 0xde, 0xb0,
 432              0x87, 0x9c, 0xb9, 0xa3, 0xdd, 0xf1, 0xb3, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0xb0, 0x87, 0xa3, 0xa3,
 433              0xa3, 0xa3, 0xb2, 0x8b, 0xb6, 0x9b, 0xf2, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
 434              0xa3, 0xf1, 0xb0, 0x87, 0xb5, 0x9a, 0xa3, 0xf3, 0x9b, 0xa3, 0xa3, 0xdc, 0xba, 0xac, 0xdf, 0xb9,
 435              0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
 436              0xd8, 0xd8, 0xd8, 0xbb, 0xb3, 0xb7, 0xf1, 0xaa, 0xf9, 0xda, 0xff, 0xd9, 0x80, 0x9a, 0xaa, 0x28,
 437              0xb4, 0x80, 0x98, 0xa7, 0x20, 0xb7, 0x97, 0x87, 0xa8, 0x66, 0x88, 0xf0, 0x79, 0x51, 0xf1, 0x90,
 438              0x2c, 0x87, 0x0c, 0xa7, 0x81, 0x97, 0x62, 0x93, 0xf0, 0x71, 0x71, 0x60, 0x85, 0x94, 0x01, 0x29,
 439              /* bank # 11 */
 440              0x51, 0x79, 0x90, 0xa5, 0xf1, 0x28, 0x4c, 0x6c, 0x87, 0x0c, 0x95, 0x18, 0x85, 0x78, 0xa3, 0x83,
 441              0x90, 0x28, 0x4c, 0x6c, 0x88, 0x6c, 0xd8, 0xf3, 0xa2, 0x82, 0x00, 0xf2, 0x10, 0xa8, 0x92, 0x19,
 442              0x80, 0xa2, 0xf2, 0xd9, 0x26, 0xd8, 0xf1, 0x88, 0xa8, 0x4d, 0xd9, 0x48, 0xd8, 0x96, 0xa8, 0x39,
 443              0x80, 0xd9, 0x3c, 0xd8, 0x95, 0x80, 0xa8, 0x39, 0xa6, 0x86, 0x98, 0xd9, 0x2c, 0xda, 0x87, 0xa7,
 444              0x2c, 0xd8, 0xa8, 0x89, 0x95, 0x19, 0xa9, 0x80, 0xd9, 0x38, 0xd8, 0xa8, 0x89, 0x39, 0xa9, 0x80,
 445              0xda, 0x3c, 0xd8, 0xa8, 0x2e, 0xa8, 0x39, 0x90, 0xd9, 0x0c, 0xd8, 0xa8, 0x95, 0x31, 0x98, 0xd9,
 446              0x0c, 0xd8, 0xa8, 0x09, 0xd9, 0xff, 0xd8, 0x01, 0xda, 0xff, 0xd8, 0x95, 0x39, 0xa9, 0xda, 0x26,
 447              0xff, 0xd8, 0x90, 0xa8, 0x0d, 0x89, 0x99, 0xa8, 0x10, 0x80, 0x98, 0x21, 0xda, 0x2e, 0xd8, 0x89,
 448              0x99, 0xa8, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x86, 0x96, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8,
 449              0x87, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x82, 0x92, 0xf3, 0x41, 0x80, 0xf1, 0xd9, 0x2e, 0xd8,
 450              0xa8, 0x82, 0xf3, 0x19, 0x80, 0xf1, 0xd9, 0x2e, 0xd8, 0x82, 0xac, 0xf3, 0xc0, 0xa2, 0x80, 0x22,
 451              0xf1, 0xa6, 0x2e, 0xa7, 0x2e, 0xa9, 0x22, 0x98, 0xa8, 0x29, 0xda, 0xac, 0xde, 0xff, 0xd8, 0xa2,
 452              0xf2, 0x2a, 0xf1, 0xa9, 0x2e, 0x82, 0x92, 0xa8, 0xf2, 0x31, 0x80, 0xa6, 0x96, 0xf1, 0xd9, 0x00,
 453              0xac, 0x8c, 0x9c, 0x0c, 0x30, 0xac, 0xde, 0xd0, 0xde, 0xff, 0xd8, 0x8c, 0x9c, 0xac, 0xd0, 0x10,
 454              0xac, 0xde, 0x80, 0x92, 0xa2, 0xf2, 0x4c, 0x82, 0xa8, 0xf1, 0xca, 0xf2, 0x35, 0xf1, 0x96, 0x88,
 455              0xa6, 0xd9, 0x00, 0xd8, 0xf1, 0xff
 456          };
 457          
 458          static const unsigned short sStartAddress = 0x0400;
 459          
 460          /* END OF SECTION COPIED FROM dmpDefaultMPU6050.c */
 461          
 462          #define INT_SRC_TAP             (0x01)
 463          #define INT_SRC_ANDROID_ORIENT  (0x08)
 464          
 465          #define DMP_FEATURE_SEND_ANY_GYRO   (DMP_FEATURE_SEND_RAW_GYRO | \
 466                                               DMP_FEATURE_SEND_CAL_GYRO)
 467          
 468          #define MAX_PACKET_LENGTH   (32)
 469          
 470          #define DMP_SAMPLE_RATE     (200)
 471          #define GYRO_SF             (46850825LL * 200 / DMP_SAMPLE_RATE)
 472          
 473          #define FIFO_CORRUPTION_CHECK
 474          #ifdef FIFO_CORRUPTION_CHECK
 475          #define QUAT_ERROR_THRESH       (1L<<24)
 476          #define QUAT_MAG_SQ_NORMALIZED  (1L<<28)
 477          #define QUAT_MAG_SQ_MIN         (QUAT_MAG_SQ_NORMALIZED - QUAT_ERROR_THRESH)
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 9   

 478          #define QUAT_MAG_SQ_MAX         (QUAT_MAG_SQ_NORMALIZED + QUAT_ERROR_THRESH)
 479          #endif
 480          
 481          struct dmp_s {
 482              void (*tap_cb)(unsigned char count, unsigned char direction);
 483              void (*android_orient_cb)(unsigned char orientation);
 484              unsigned short orient;
 485              unsigned short feature_mask;
 486              unsigned short fifo_rate;
 487              unsigned char packet_length;
 488          };
 489          
 490          //static struct dmp_s dmp = {
 491          //    .tap_cb = NULL,
 492          //    .android_orient_cb = NULL,
 493          //    .orient = 0,
 494          //    .feature_mask = 0,
 495          //    .fifo_rate = 0,
 496          //    .packet_length = 0
 497          //};
 498          static struct dmp_s dmp={
 499            NULL,
 500            NULL,
 501            0,
 502            0,
 503            0,
 504            0
 505          };
 506          /**
 507           *  @brief  Load the DMP with this image.
 508           *  @return 0 if successful.
 509           */
 510          int dmp_load_motion_driver_firmware(void)
 511          {
 512              return mpu_load_firmware(DMP_CODE_SIZE, dmp_memory, sStartAddress,
 513                  DMP_SAMPLE_RATE);
 514          }
 515          
 516          /**
 517           *  @brief      Push gyro and accel orientation to the DMP.
 518           *  The orientation is represented here as the output of
 519           *  @e inv_orientation_matrix_to_scalar.
 520           *  @param[in]  orient  Gyro and accel orientation in body frame.
 521           *  @return     0 if successful.
 522           */
 523          int dmp_set_orientation(unsigned short orient)
 524          {
 525              unsigned char gyro_regs[3], accel_regs[3];
 526              const unsigned char gyro_axes[3] = {DINA4C, DINACD, DINA6C};
 527              const unsigned char accel_axes[3] = {DINA0C, DINAC9, DINA2C};
 528              const unsigned char gyro_sign[3] = {DINA36, DINA56, DINA76};
 529              const unsigned char accel_sign[3] = {DINA26, DINA46, DINA66};
 530          
 531              gyro_regs[0] = gyro_axes[orient & 3];
 532              gyro_regs[1] = gyro_axes[(orient >> 3) & 3];
 533              gyro_regs[2] = gyro_axes[(orient >> 6) & 3];
 534              accel_regs[0] = accel_axes[orient & 3];
 535              accel_regs[1] = accel_axes[(orient >> 3) & 3];
 536              accel_regs[2] = accel_axes[(orient >> 6) & 3];
 537          
 538              /* Chip-to-body, axes only. */
 539              if (mpu_write_mem(FCFG_1, 3, gyro_regs))
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 10  

 540                  return -1;
 541              if (mpu_write_mem(FCFG_2, 3, accel_regs))
 542                  return -1;
 543          
 544              memcpy(gyro_regs, gyro_sign, 3);
 545              memcpy(accel_regs, accel_sign, 3);
 546              if (orient & 4) {
 547                  gyro_regs[0] |= 1;
 548                  accel_regs[0] |= 1;
 549              }
 550              if (orient & 0x20) {
 551                  gyro_regs[1] |= 1;
 552                  accel_regs[1] |= 1;
 553              }
 554              if (orient & 0x100) {
 555                  gyro_regs[2] |= 1;
 556                  accel_regs[2] |= 1;
 557              }
 558          
 559              /* Chip-to-body, sign only. */
 560              if (mpu_write_mem(FCFG_3, 3, gyro_regs))
 561                  return -1;
 562              if (mpu_write_mem(FCFG_7, 3, accel_regs))
 563                  return -1;
 564              dmp.orient = orient;
 565              return 0;
 566          }
 567          
 568          /**
 569           *  @brief      Push gyro biases to the DMP.
 570           *  Because the gyro integration is handled in the DMP, any gyro biases
 571           *  calculated by the MPL should be pushed down to DMP memory to remove
 572           *  3-axis quaternion drift.
 573           *  \n NOTE: If the DMP-based gyro calibration is enabled, the DMP will
 574           *  overwrite the biases written to this location once a new one is computed.
 575           *  @param[in]  bias    Gyro biases in q16.
 576           *  @return     0 if successful.
 577           */
 578          int dmp_set_gyro_bias(long *bias)
 579          {
 580              long gyro_bias_body[3];
 581              unsigned char regs[4];
 582          
 583              gyro_bias_body[0] = bias[dmp.orient & 3];
 584              if (dmp.orient & 4)
 585                  gyro_bias_body[0] *= -1;
 586              gyro_bias_body[1] = bias[(dmp.orient >> 3) & 3];
 587              if (dmp.orient & 0x20)
 588                  gyro_bias_body[1] *= -1;
 589              gyro_bias_body[2] = bias[(dmp.orient >> 6) & 3];
 590              if (dmp.orient & 0x100)
 591                  gyro_bias_body[2] *= -1;
 592          
 593          #ifdef EMPL_NO_64BIT
                  gyro_bias_body[0] = (long)(((float)gyro_bias_body[0] * GYRO_SF) / 1073741824.f);
                  gyro_bias_body[1] = (long)(((float)gyro_bias_body[1] * GYRO_SF) / 1073741824.f);
                  gyro_bias_body[2] = (long)(((float)gyro_bias_body[2] * GYRO_SF) / 1073741824.f);
              #else
 598              gyro_bias_body[0] = (long)(((long long)gyro_bias_body[0] * GYRO_SF) >> 30);
 599              gyro_bias_body[1] = (long)(((long long)gyro_bias_body[1] * GYRO_SF) >> 30);
 600              gyro_bias_body[2] = (long)(((long long)gyro_bias_body[2] * GYRO_SF) >> 30);
 601          #endif
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 11  

 602          
 603              regs[0] = (unsigned char)((gyro_bias_body[0] >> 24) & 0xFF);
 604              regs[1] = (unsigned char)((gyro_bias_body[0] >> 16) & 0xFF);
 605              regs[2] = (unsigned char)((gyro_bias_body[0] >> 8) & 0xFF);
 606              regs[3] = (unsigned char)(gyro_bias_body[0] & 0xFF);
 607              if (mpu_write_mem(D_EXT_GYRO_BIAS_X, 4, regs))
 608                  return -1;
 609          
 610              regs[0] = (unsigned char)((gyro_bias_body[1] >> 24) & 0xFF);
 611              regs[1] = (unsigned char)((gyro_bias_body[1] >> 16) & 0xFF);
 612              regs[2] = (unsigned char)((gyro_bias_body[1] >> 8) & 0xFF);
 613              regs[3] = (unsigned char)(gyro_bias_body[1] & 0xFF);
 614              if (mpu_write_mem(D_EXT_GYRO_BIAS_Y, 4, regs))
 615                  return -1;
 616          
 617              regs[0] = (unsigned char)((gyro_bias_body[2] >> 24) & 0xFF);
 618              regs[1] = (unsigned char)((gyro_bias_body[2] >> 16) & 0xFF);
 619              regs[2] = (unsigned char)((gyro_bias_body[2] >> 8) & 0xFF);
 620              regs[3] = (unsigned char)(gyro_bias_body[2] & 0xFF);
 621              return mpu_write_mem(D_EXT_GYRO_BIAS_Z, 4, regs);
 622          }
 623          
 624          /**
 625           *  @brief      Push accel biases to the DMP.
 626           *  These biases will be removed from the DMP 6-axis quaternion.
 627           *  @param[in]  bias    Accel biases in q16.
 628           *  @return     0 if successful.
 629           */
 630          int dmp_set_accel_bias(long *bias)
 631          {
 632              long accel_bias_body[3];
 633              unsigned char regs[12];
 634              long long accel_sf;
 635              unsigned short accel_sens;
 636          
 637              mpu_get_accel_sens(&accel_sens);
 638              accel_sf = (long long)accel_sens << 15;
 639              //__no_operation();
 640          
 641              accel_bias_body[0] = bias[dmp.orient & 3];
 642              if (dmp.orient & 4)
 643                  accel_bias_body[0] *= -1;
 644              accel_bias_body[1] = bias[(dmp.orient >> 3) & 3];
 645              if (dmp.orient & 0x20)
 646                  accel_bias_body[1] *= -1;
 647              accel_bias_body[2] = bias[(dmp.orient >> 6) & 3];
 648              if (dmp.orient & 0x100)
 649                  accel_bias_body[2] *= -1;
 650          
 651          #ifdef EMPL_NO_64BIT
                  accel_bias_body[0] = (long)(((float)accel_bias_body[0] * accel_sf) / 1073741824.f);
                  accel_bias_body[1] = (long)(((float)accel_bias_body[1] * accel_sf) / 1073741824.f);
                  accel_bias_body[2] = (long)(((float)accel_bias_body[2] * accel_sf) / 1073741824.f);
              #else
 656              accel_bias_body[0] = (long)(((long long)accel_bias_body[0] * accel_sf) >> 30);
 657              accel_bias_body[1] = (long)(((long long)accel_bias_body[1] * accel_sf) >> 30);
 658              accel_bias_body[2] = (long)(((long long)accel_bias_body[2] * accel_sf) >> 30);
 659          #endif
 660          
 661              regs[0] = (unsigned char)((accel_bias_body[0] >> 24) & 0xFF);
 662              regs[1] = (unsigned char)((accel_bias_body[0] >> 16) & 0xFF);
 663              regs[2] = (unsigned char)((accel_bias_body[0] >> 8) & 0xFF);
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 12  

 664              regs[3] = (unsigned char)(accel_bias_body[0] & 0xFF);
 665              regs[4] = (unsigned char)((accel_bias_body[1] >> 24) & 0xFF);
 666              regs[5] = (unsigned char)((accel_bias_body[1] >> 16) & 0xFF);
 667              regs[6] = (unsigned char)((accel_bias_body[1] >> 8) & 0xFF);
 668              regs[7] = (unsigned char)(accel_bias_body[1] & 0xFF);
 669              regs[8] = (unsigned char)((accel_bias_body[2] >> 24) & 0xFF);
 670              regs[9] = (unsigned char)((accel_bias_body[2] >> 16) & 0xFF);
 671              regs[10] = (unsigned char)((accel_bias_body[2] >> 8) & 0xFF);
 672              regs[11] = (unsigned char)(accel_bias_body[2] & 0xFF);
 673              return mpu_write_mem(D_ACCEL_BIAS, 12, regs);
 674          }
 675          
 676          /**
 677           *  @brief      Set DMP output rate.
 678           *  Only used when DMP is on.
 679           *  @param[in]  rate    Desired fifo rate (Hz).
 680           *  @return     0 if successful.
 681           */
 682          int dmp_set_fifo_rate(unsigned short rate)
 683          {
 684              const unsigned char regs_end[12] = {DINAFE, DINAF2, DINAAB,
 685                  0xc4, DINAAA, DINAF1, DINADF, DINADF, 0xBB, 0xAF, DINADF, DINADF};
 686              unsigned short div;
 687              unsigned char tmp[8];
 688          
 689              if (rate > DMP_SAMPLE_RATE)
 690                  return -1;
 691              div = DMP_SAMPLE_RATE / rate - 1;
 692              tmp[0] = (unsigned char)((div >> 8) & 0xFF);
 693              tmp[1] = (unsigned char)(div & 0xFF);
 694              if (mpu_write_mem(D_0_22, 2, tmp))
 695                  return -1;
 696              if (mpu_write_mem(CFG_6, 12, (unsigned char*)regs_end))
 697                  return -1;
 698          
 699              dmp.fifo_rate = rate;
 700              return 0;
 701          }
 702          
 703          /**
 704           *  @brief      Get DMP output rate.
 705           *  @param[out] rate    Current fifo rate (Hz).
 706           *  @return     0 if successful.
 707           */
 708          int dmp_get_fifo_rate(unsigned short *rate)
 709          {
 710              rate[0] = dmp.fifo_rate;
 711              return 0;
 712          }
 713          
 714          /**
 715           *  @brief      Set tap threshold for a specific axis.
 716           *  @param[in]  axis    1, 2, and 4 for XYZ accel, respectively.
 717           *  @param[in]  thresh  Tap threshold, in mg/ms.
 718           *  @return     0 if successful.
 719           */
 720          int dmp_set_tap_thresh(unsigned char axis, unsigned short thresh)
 721          {
 722              unsigned char tmp[4], accel_fsr;
 723              float scaled_thresh;
 724              unsigned short dmp_thresh, dmp_thresh_2;
 725              if (!(axis & TAP_XYZ) || thresh > 1600)
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 13  

 726                  return -1;
 727          
 728              scaled_thresh = (float)thresh / DMP_SAMPLE_RATE;
 729          
 730              mpu_get_accel_fsr(&accel_fsr);
 731              switch (accel_fsr) {
 732              case 2:
 733                  dmp_thresh = (unsigned short)(scaled_thresh * 16384);
 734                  /* dmp_thresh * 0.75 */
 735                  dmp_thresh_2 = (unsigned short)(scaled_thresh * 12288);
 736                  break;
 737              case 4:
 738                  dmp_thresh = (unsigned short)(scaled_thresh * 8192);
 739                  /* dmp_thresh * 0.75 */
 740                  dmp_thresh_2 = (unsigned short)(scaled_thresh * 6144);
 741                  break;
 742              case 8:
 743                  dmp_thresh = (unsigned short)(scaled_thresh * 4096);
 744                  /* dmp_thresh * 0.75 */
 745                  dmp_thresh_2 = (unsigned short)(scaled_thresh * 3072);
 746                  break;
 747              case 16:
 748                  dmp_thresh = (unsigned short)(scaled_thresh * 2048);
 749                  /* dmp_thresh * 0.75 */
 750                  dmp_thresh_2 = (unsigned short)(scaled_thresh * 1536);
 751                  break;
 752              default:
 753                  return -1;
 754              }
 755              tmp[0] = (unsigned char)(dmp_thresh >> 8);
 756              tmp[1] = (unsigned char)(dmp_thresh & 0xFF);
 757              tmp[2] = (unsigned char)(dmp_thresh_2 >> 8);
 758              tmp[3] = (unsigned char)(dmp_thresh_2 & 0xFF);
 759          
 760              if (axis & TAP_X) {
 761                  if (mpu_write_mem(DMP_TAP_THX, 2, tmp))
 762                      return -1;
 763                  if (mpu_write_mem(D_1_36, 2, tmp+2))
 764                      return -1;
 765              }
 766              if (axis & TAP_Y) {
 767                  if (mpu_write_mem(DMP_TAP_THY, 2, tmp))
 768                      return -1;
 769                  if (mpu_write_mem(D_1_40, 2, tmp+2))
 770                      return -1;
 771              }
 772              if (axis & TAP_Z) {
 773                  if (mpu_write_mem(DMP_TAP_THZ, 2, tmp))
 774                      return -1;
 775                  if (mpu_write_mem(D_1_44, 2, tmp+2))
 776                      return -1;
 777              }
 778              return 0;
 779          }
 780          
 781          /**
 782           *  @brief      Set which axes will register a tap.
 783           *  @param[in]  axis    1, 2, and 4 for XYZ, respectively.
 784           *  @return     0 if successful.
 785           */
 786          int dmp_set_tap_axes(unsigned char axis)
 787          {
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 14  

 788              unsigned char tmp = 0;
 789          
 790              if (axis & TAP_X)
 791                  tmp |= 0x30;
 792              if (axis & TAP_Y)
 793                  tmp |= 0x0C;
 794              if (axis & TAP_Z)
 795                  tmp |= 0x03;
 796              return mpu_write_mem(D_1_72, 1, &tmp);
 797          }
 798          
 799          /**
 800           *  @brief      Set minimum number of taps needed for an interrupt.
 801           *  @param[in]  min_taps    Minimum consecutive taps (1-4).
 802           *  @return     0 if successful.
 803           */
 804          int dmp_set_tap_count(unsigned char min_taps)
 805          {
 806              unsigned char tmp;
 807          
 808              if (min_taps < 1)
 809                  min_taps = 1;
 810              else if (min_taps > 4)
 811                  min_taps = 4;
 812          
 813              tmp = min_taps - 1;
 814              return mpu_write_mem(D_1_79, 1, &tmp);
 815          }
 816          
 817          /**
 818           *  @brief      Set length between valid taps.
 819           *  @param[in]  time    Milliseconds between taps.
 820           *  @return     0 if successful.
 821           */
 822          int dmp_set_tap_time(unsigned short time)
 823          {
 824              unsigned short dmp_time;
 825              unsigned char tmp[2];
 826          
 827              dmp_time = time / (1000 / DMP_SAMPLE_RATE);
 828              tmp[0] = (unsigned char)(dmp_time >> 8);
 829              tmp[1] = (unsigned char)(dmp_time & 0xFF);
 830              return mpu_write_mem(DMP_TAPW_MIN, 2, tmp);
 831          }
 832          
 833          /**
 834           *  @brief      Set max time between taps to register as a multi-tap.
 835           *  @param[in]  time    Max milliseconds between taps.
 836           *  @return     0 if successful.
 837           */
 838          int dmp_set_tap_time_multi(unsigned short time)
 839          {
 840              unsigned short dmp_time;
 841              unsigned char tmp[2];
 842          
 843              dmp_time = time / (1000 / DMP_SAMPLE_RATE);
 844              tmp[0] = (unsigned char)(dmp_time >> 8);
 845              tmp[1] = (unsigned char)(dmp_time & 0xFF);
 846              return mpu_write_mem(D_1_218, 2, tmp);
 847          }
 848          
 849          /**
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 15  

 850           *  @brief      Set shake rejection threshold.
 851           *  If the DMP detects a gyro sample larger than @e thresh, taps are rejected.
 852           *  @param[in]  sf      Gyro scale factor.
 853           *  @param[in]  thresh  Gyro threshold in dps.
 854           *  @return     0 if successful.
 855           */
 856          int dmp_set_shake_reject_thresh(long sf, unsigned short thresh)
 857          {
 858              unsigned char tmp[4];
 859              long thresh_scaled = sf / 1000 * thresh;
 860              tmp[0] = (unsigned char)(((long)thresh_scaled >> 24) & 0xFF);
 861              tmp[1] = (unsigned char)(((long)thresh_scaled >> 16) & 0xFF);
 862              tmp[2] = (unsigned char)(((long)thresh_scaled >> 8) & 0xFF);
 863              tmp[3] = (unsigned char)((long)thresh_scaled & 0xFF);
 864              return mpu_write_mem(D_1_92, 4, tmp);
 865          }
 866          
 867          /**
 868           *  @brief      Set shake rejection time.
 869           *  Sets the length of time that the gyro must be outside of the threshold set
 870           *  by @e gyro_set_shake_reject_thresh before taps are rejected. A mandatory
 871           *  60 ms is added to this parameter.
 872           *  @param[in]  time    Time in milliseconds.
 873           *  @return     0 if successful.
 874           */
 875          int dmp_set_shake_reject_time(unsigned short time)
 876          {
 877              unsigned char tmp[2];
 878          
 879              time /= (1000 / DMP_SAMPLE_RATE);
 880              tmp[0] = time >> 8;
 881              tmp[1] = time & 0xFF;
 882              return mpu_write_mem(D_1_90,2,tmp);
 883          }
 884          
 885          /**
 886           *  @brief      Set shake rejection timeout.
 887           *  Sets the length of time after a shake rejection that the gyro must stay
 888           *  inside of the threshold before taps can be detected again. A mandatory
 889           *  60 ms is added to this parameter.
 890           *  @param[in]  time    Time in milliseconds.
 891           *  @return     0 if successful.
 892           */
 893          int dmp_set_shake_reject_timeout(unsigned short time)
 894          {
 895              unsigned char tmp[2];
 896          
 897              time /= (1000 / DMP_SAMPLE_RATE);
 898              tmp[0] = time >> 8;
 899              tmp[1] = time & 0xFF;
 900              return mpu_write_mem(D_1_88,2,tmp);
 901          }
 902          
 903          /**
 904           *  @brief      Get current step count.
 905           *  @param[out] count   Number of steps detected.
 906           *  @return     0 if successful.
 907           */
 908          int dmp_get_pedometer_step_count(unsigned long *count)
 909          {
 910              unsigned char tmp[4];
 911              if (!count)
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 16  

 912                  return -1;
 913          
 914              if (mpu_read_mem(D_PEDSTD_STEPCTR, 4, tmp))
 915                  return -1;
 916          
 917              count[0] = ((unsigned long)tmp[0] << 24) | ((unsigned long)tmp[1] << 16) |
 918                  ((unsigned long)tmp[2] << 8) | tmp[3];
 919              return 0;
 920          }
 921          
 922          /**
 923           *  @brief      Overwrite current step count.
 924           *  WARNING: This function writes to DMP memory and could potentially encounter
 925           *  a race condition if called while the pedometer is enabled.
 926           *  @param[in]  count   New step count.
 927           *  @return     0 if successful.
 928           */
 929          int dmp_set_pedometer_step_count(unsigned long count)
 930          {
 931              unsigned char tmp[4];
 932          
 933              tmp[0] = (unsigned char)((count >> 24) & 0xFF);
 934              tmp[1] = (unsigned char)((count >> 16) & 0xFF);
 935              tmp[2] = (unsigned char)((count >> 8) & 0xFF);
 936              tmp[3] = (unsigned char)(count & 0xFF);
 937              return mpu_write_mem(D_PEDSTD_STEPCTR, 4, tmp);
 938          }
 939          
 940          /**
 941           *  @brief      Get duration of walking time.
 942           *  @param[in]  time    Walk time in milliseconds.
 943           *  @return     0 if successful.
 944           */
 945          int dmp_get_pedometer_walk_time(unsigned long *time)
 946          {
 947              unsigned char tmp[4];
 948              if (!time)
 949                  return -1;
 950          
 951              if (mpu_read_mem(D_PEDSTD_TIMECTR, 4, tmp))
 952                  return -1;
 953          
 954              time[0] = (((unsigned long)tmp[0] << 24) | ((unsigned long)tmp[1] << 16) |
 955                  ((unsigned long)tmp[2] << 8) | tmp[3]) * 20;
 956              return 0;
 957          }
 958          
 959          /**
 960           *  @brief      Overwrite current walk time.
 961           *  WARNING: This function writes to DMP memory and could potentially encounter
 962           *  a race condition if called while the pedometer is enabled.
 963           *  @param[in]  time    New walk time in milliseconds.
 964           */
 965          int dmp_set_pedometer_walk_time(unsigned long time)
 966          {
 967              unsigned char tmp[4];
 968          
 969              time /= 20;
 970          
 971              tmp[0] = (unsigned char)((time >> 24) & 0xFF);
 972              tmp[1] = (unsigned char)((time >> 16) & 0xFF);
 973              tmp[2] = (unsigned char)((time >> 8) & 0xFF);
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 17  

 974              tmp[3] = (unsigned char)(time & 0xFF);
 975              return mpu_write_mem(D_PEDSTD_TIMECTR, 4, tmp);
 976          }
 977          
 978          /**
 979           *  @brief      Enable DMP features.
 980           *  The following \#define's are used in the input mask:
 981           *  \n DMP_FEATURE_TAP
 982           *  \n DMP_FEATURE_ANDROID_ORIENT
 983           *  \n DMP_FEATURE_LP_QUAT
 984           *  \n DMP_FEATURE_6X_LP_QUAT
 985           *  \n DMP_FEATURE_GYRO_CAL
 986           *  \n DMP_FEATURE_SEND_RAW_ACCEL
 987           *  \n DMP_FEATURE_SEND_RAW_GYRO
 988           *  \n NOTE: DMP_FEATURE_LP_QUAT and DMP_FEATURE_6X_LP_QUAT are mutually
 989           *  exclusive.
 990           *  \n NOTE: DMP_FEATURE_SEND_RAW_GYRO and DMP_FEATURE_SEND_CAL_GYRO are also
 991           *  mutually exclusive.
 992           *  @param[in]  mask    Mask of features to enable.
 993           *  @return     0 if successful.
 994           */
 995          int dmp_enable_feature(unsigned short mask)
 996          {
 997              unsigned char tmp[10];
 998          
 999              /* TODO: All of these settings can probably be integrated into the default
1000               * DMP image.
1001               */
1002              /* Set integration scale factor. */
1003              tmp[0] = (unsigned char)((GYRO_SF >> 24) & 0xFF);
1004              tmp[1] = (unsigned char)((GYRO_SF >> 16) & 0xFF);
1005              tmp[2] = (unsigned char)((GYRO_SF >> 8) & 0xFF);
1006              tmp[3] = (unsigned char)(GYRO_SF & 0xFF);
1007              mpu_write_mem(D_0_104, 4, tmp);
1008          
1009              /* Send sensor data to the FIFO. */
1010              tmp[0] = 0xA3;
1011              if (mask & DMP_FEATURE_SEND_RAW_ACCEL) {
1012                  tmp[1] = 0xC0;
1013                  tmp[2] = 0xC8;
1014                  tmp[3] = 0xC2;
1015              } else {
1016                  tmp[1] = 0xA3;
1017                  tmp[2] = 0xA3;
1018                  tmp[3] = 0xA3;
1019              }
1020              if (mask & DMP_FEATURE_SEND_ANY_GYRO) {
1021                  tmp[4] = 0xC4;
1022                  tmp[5] = 0xCC;
1023                  tmp[6] = 0xC6;
1024              } else {
1025                  tmp[4] = 0xA3;
1026                  tmp[5] = 0xA3;
1027                  tmp[6] = 0xA3;
1028              }
1029              tmp[7] = 0xA3;
1030              tmp[8] = 0xA3;
1031              tmp[9] = 0xA3;
1032              mpu_write_mem(CFG_15,10,tmp);
1033          
1034              /* Send gesture data to the FIFO. */
1035              if (mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 18  

1036                  tmp[0] = DINA20;
1037              else
1038                  tmp[0] = 0xD8;
1039              mpu_write_mem(CFG_27,1,tmp);
1040          
1041              if (mask & DMP_FEATURE_GYRO_CAL)
1042                  dmp_enable_gyro_cal(1);
1043              else
1044                  dmp_enable_gyro_cal(0);
1045          
1046              if (mask & DMP_FEATURE_SEND_ANY_GYRO) {
1047                  if (mask & DMP_FEATURE_SEND_CAL_GYRO) {
1048                      tmp[0] = 0xB2;
1049                      tmp[1] = 0x8B;
1050                      tmp[2] = 0xB6;
1051                      tmp[3] = 0x9B;
1052                  } else {
1053                      tmp[0] = DINAC0;
1054                      tmp[1] = DINA80;
1055                      tmp[2] = DINAC2;
1056                      tmp[3] = DINA90;
1057                  }
1058                  mpu_write_mem(CFG_GYRO_RAW_DATA, 4, tmp);
1059              }
1060          
1061              if (mask & DMP_FEATURE_TAP) {
1062                  /* Enable tap. */
1063                  tmp[0] = 0xF8;
1064                  mpu_write_mem(CFG_20, 1, tmp);
1065                  dmp_set_tap_thresh(TAP_XYZ, 250);
1066                  dmp_set_tap_axes(TAP_XYZ);
1067                  dmp_set_tap_count(1);
1068                  dmp_set_tap_time(100);
1069                  dmp_set_tap_time_multi(500);
1070          
1071                  dmp_set_shake_reject_thresh(GYRO_SF, 200);
1072                  dmp_set_shake_reject_time(40);
1073                  dmp_set_shake_reject_timeout(10);
1074              } else {
1075                  tmp[0] = 0xD8;
1076                  mpu_write_mem(CFG_20, 1, tmp);
1077              }
1078          
1079              if (mask & DMP_FEATURE_ANDROID_ORIENT) {
1080                  tmp[0] = 0xD9;
1081              } else
1082                  tmp[0] = 0xD8;
1083              mpu_write_mem(CFG_ANDROID_ORIENT_INT, 1, tmp);
1084          
1085              if (mask & DMP_FEATURE_LP_QUAT)
1086                  dmp_enable_lp_quat(1);
1087              else
1088                  dmp_enable_lp_quat(0);
1089          
1090              if (mask & DMP_FEATURE_6X_LP_QUAT)
1091                  dmp_enable_6x_lp_quat(1);
1092              else
1093                  dmp_enable_6x_lp_quat(0);
1094          
1095              /* Pedometer is always enabled. */
1096              dmp.feature_mask = mask | DMP_FEATURE_PEDOMETER;
1097              mpu_reset_fifo();
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 19  

1098          
1099              dmp.packet_length = 0;
1100              if (mask & DMP_FEATURE_SEND_RAW_ACCEL)
1101                  dmp.packet_length += 6;
1102              if (mask & DMP_FEATURE_SEND_ANY_GYRO)
1103                  dmp.packet_length += 6;
1104              if (mask & (DMP_FEATURE_LP_QUAT | DMP_FEATURE_6X_LP_QUAT))
1105                  dmp.packet_length += 16;
1106              if (mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
1107                  dmp.packet_length += 4;
1108          
1109              return 0;
1110          }
1111          
1112          /**
1113           *  @brief      Get list of currently enabled DMP features.
1114           *  @param[out] Mask of enabled features.
1115           *  @return     0 if successful.
1116           */
1117          int dmp_get_enabled_features(unsigned short *mask)
1118          {
1119              mask[0] = dmp.feature_mask;
1120              return 0;
1121          }
1122          
1123          /**
1124           *  @brief      Calibrate the gyro data in the DMP.
1125           *  After eight seconds of no motion, the DMP will compute gyro biases and
1126           *  subtract them from the quaternion output. If @e dmp_enable_feature is
1127           *  called with @e DMP_FEATURE_SEND_CAL_GYRO, the biases will also be
1128           *  subtracted from the gyro output.
1129           *  @param[in]  enable  1 to enable gyro calibration.
1130           *  @return     0 if successful.
1131           */
1132          int dmp_enable_gyro_cal(unsigned char enable)
1133          {
1134              if (enable) {
1135                  unsigned char regs[9] = {0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35, 0x5d};
1136                  return mpu_write_mem(CFG_MOTION_BIAS, 9, regs);
1137              } else {
1138                  unsigned char regs[9] = {0xb8, 0xaa, 0xaa, 0xaa, 0xb0, 0x88, 0xc3, 0xc5, 0xc7};
1139                  return mpu_write_mem(CFG_MOTION_BIAS, 9, regs);
1140              }
1141          }
1142          
1143          /**
1144           *  @brief      Generate 3-axis quaternions from the DMP.
1145           *  In this driver, the 3-axis and 6-axis DMP quaternion features are mutually
1146           *  exclusive.
1147           *  @param[in]  enable  1 to enable 3-axis quaternion.
1148           *  @return     0 if successful.
1149           */
1150          int dmp_enable_lp_quat(unsigned char enable)
1151          {
1152              unsigned char regs[4];
1153              if (enable) {
1154                  regs[0] = DINBC0;
1155                  regs[1] = DINBC2;
1156                  regs[2] = DINBC4;
1157                  regs[3] = DINBC6;
1158              }
1159              else
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 20  

1160                  memset(regs, 0x8B, 4);
1161          
1162              mpu_write_mem(CFG_LP_QUAT, 4, regs);
1163          
1164              return mpu_reset_fifo();
1165          }
1166          
1167          /**
1168           *  @brief       Generate 6-axis quaternions from the DMP.
1169           *  In this driver, the 3-axis and 6-axis DMP quaternion features are mutually
1170           *  exclusive.
1171           *  @param[in]   enable  1 to enable 6-axis quaternion.
1172           *  @return      0 if successful.
1173           */
1174          int dmp_enable_6x_lp_quat(unsigned char enable)
1175          {
1176              unsigned char regs[4];
1177              if (enable) {
1178                  regs[0] = DINA20;
1179                  regs[1] = DINA28;
1180                  regs[2] = DINA30;
1181                  regs[3] = DINA38;
1182              } else
1183                  memset(regs, 0xA3, 4);
1184          
1185              mpu_write_mem(CFG_8, 4, regs);
1186          
1187              return mpu_reset_fifo();
1188          }
1189          
1190          /**
1191           *  @brief      Decode the four-byte gesture data and execute any callbacks.
1192           *  @param[in]  gesture Gesture data from DMP packet.
1193           *  @return     0 if successful.
1194           */
1195          static int decode_gesture(unsigned char *gesture)
1196          {
1197              unsigned char tap, android_orient;
1198          
1199              android_orient = gesture[3] & 0xC0;
1200              tap = 0x3F & gesture[3];
1201          
1202              if (gesture[1] & INT_SRC_TAP) {
1203                  unsigned char direction, count;
1204                  direction = tap >> 3;
1205                  count = (tap % 8) + 1;
1206                  if (dmp.tap_cb)
1207                      dmp.tap_cb(direction, count);
1208              }
1209          
1210              if (gesture[1] & INT_SRC_ANDROID_ORIENT) {
1211                  if (dmp.android_orient_cb)
1212                      dmp.android_orient_cb(android_orient >> 6);
1213              }
1214          
1215              return 0;
1216          }
1217          
1218          /**
1219           *  @brief      Specify when a DMP interrupt should occur.
1220           *  A DMP interrupt can be configured to trigger on either of the two
1221           *  conditions below:
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 21  

1222           *  \n a. One FIFO period has elapsed (set by @e mpu_set_sample_rate).
1223           *  \n b. A tap event has been detected.
1224           *  @param[in]  mode    DMP_INT_GESTURE or DMP_INT_CONTINUOUS.
1225           *  @return     0 if successful.
1226           */
1227          int dmp_set_interrupt_mode(unsigned char mode)
1228          {
1229              const unsigned char regs_continuous[11] =
1230                  {0xd8, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0x09, 0xb4, 0xd9};
1231              const unsigned char regs_gesture[11] =
1232                  {0xda, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0xda, 0xb4, 0xda};
1233          
1234              switch (mode) {
1235              case DMP_INT_CONTINUOUS:
1236                  return mpu_write_mem(CFG_FIFO_ON_EVENT, 11,
1237                      (unsigned char*)regs_continuous);
1238              case DMP_INT_GESTURE:
1239                  return mpu_write_mem(CFG_FIFO_ON_EVENT, 11,
1240                      (unsigned char*)regs_gesture);
1241              default:
1242                  return -1;
1243              }
1244          }
1245          
1246          /**
1247           *  @brief      Get one packet from the FIFO.
1248           *  If @e sensors does not contain a particular sensor, disregard the data
1249           *  returned to that pointer.
1250           *  \n @e sensors can contain a combination of the following flags:
1251           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1252           *  \n INV_XYZ_GYRO
1253           *  \n INV_XYZ_ACCEL
1254           *  \n INV_WXYZ_QUAT
1255           *  \n If the FIFO has no new data, @e sensors will be zero.
1256           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
1257           *  return a non-zero error code.
1258           *  @param[out] gyro        Gyro data in hardware units.
1259           *  @param[out] accel       Accel data in hardware units.
1260           *  @param[out] quat        3-axis quaternion data in hardware units.
1261           *  @param[out] timestamp   Timestamp in milliseconds.
1262           *  @param[out] sensors     Mask of sensors read from FIFO.
1263           *  @param[out] more        Number of remaining packets.
1264           *  @return     0 if successful.
1265           */
1266          int dmp_read_fifo(short *gyro, short *accel, long *quat,
1267              unsigned long *timestamp, short *sensors, unsigned char *more)
1268          {
1269              unsigned char fifo_data[MAX_PACKET_LENGTH];
1270              unsigned char ii = 0;
1271          
1272              /* TODO: sensors[0] only changes when dmp_enable_feature is called. We can
1273               * cache this value and save some cycles.
1274               */
1275              sensors[0] = 0;
1276          
1277              /* Get a packet. */
1278              if (mpu_read_fifo_stream(dmp.packet_length, fifo_data, more))
1279                  return -1;
1280          
1281              /* Parse DMP packet. */
1282              if (dmp.feature_mask & (DMP_FEATURE_LP_QUAT | DMP_FEATURE_6X_LP_QUAT)) {
1283          #ifdef FIFO_CORRUPTION_CHECK
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 22  

1284                  long quat_q14[4], quat_mag_sq;
1285          #endif
1286                  quat[0] = ((long)fifo_data[0] << 24) | ((long)fifo_data[1] << 16) |
1287                      ((long)fifo_data[2] << 8) | fifo_data[3];
1288                  quat[1] = ((long)fifo_data[4] << 24) | ((long)fifo_data[5] << 16) |
1289                      ((long)fifo_data[6] << 8) | fifo_data[7];
1290                  quat[2] = ((long)fifo_data[8] << 24) | ((long)fifo_data[9] << 16) |
1291                      ((long)fifo_data[10] << 8) | fifo_data[11];
1292                  quat[3] = ((long)fifo_data[12] << 24) | ((long)fifo_data[13] << 16) |
1293                      ((long)fifo_data[14] << 8) | fifo_data[15];
1294                  ii += 16;
1295          #ifdef FIFO_CORRUPTION_CHECK
1296                  /* We can detect a corrupted FIFO by monitoring the quaternion data and
1297                   * ensuring that the magnitude is always normalized to one. This
1298                   * shouldn't happen in normal operation, but if an I2C error occurs,
1299                   * the FIFO reads might become misaligned.
1300                   *
1301                   * Let's start by scaling down the quaternion data to avoid long long
1302                   * math.
1303                   */
1304                  quat_q14[0] = quat[0] >> 16;
1305                  quat_q14[1] = quat[1] >> 16;
1306                  quat_q14[2] = quat[2] >> 16;
1307                  quat_q14[3] = quat[3] >> 16;
1308                  quat_mag_sq = quat_q14[0] * quat_q14[0] + quat_q14[1] * quat_q14[1] +
1309                      quat_q14[2] * quat_q14[2] + quat_q14[3] * quat_q14[3];
1310                  if ((quat_mag_sq < QUAT_MAG_SQ_MIN) ||
1311                      (quat_mag_sq > QUAT_MAG_SQ_MAX)) {
1312                      /* Quaternion is outside of the acceptable threshold. */
1313                      mpu_reset_fifo();
1314                      sensors[0] = 0;
1315                      return -1;
1316                  }
1317                  sensors[0] |= INV_WXYZ_QUAT;
1318          #endif
1319              }
1320          
1321              if (dmp.feature_mask & DMP_FEATURE_SEND_RAW_ACCEL) {
1322                  accel[0] = ((short)fifo_data[ii+0] << 8) | fifo_data[ii+1];
1323                  accel[1] = ((short)fifo_data[ii+2] << 8) | fifo_data[ii+3];
1324                  accel[2] = ((short)fifo_data[ii+4] << 8) | fifo_data[ii+5];
1325                  ii += 6;
1326                  sensors[0] |= INV_XYZ_ACCEL;
1327              }
1328          
1329              if (dmp.feature_mask & DMP_FEATURE_SEND_ANY_GYRO) {
1330                  gyro[0] = ((short)fifo_data[ii+0] << 8) | fifo_data[ii+1];
1331                  gyro[1] = ((short)fifo_data[ii+2] << 8) | fifo_data[ii+3];
1332                  gyro[2] = ((short)fifo_data[ii+4] << 8) | fifo_data[ii+5];
1333                  ii += 6;
1334                  sensors[0] |= INV_XYZ_GYRO;
1335              }
1336          
1337              /* Gesture data is at the end of the DMP packet. Parse it and call
1338               * the gesture callbacks (if registered).
1339               */
1340              if (dmp.feature_mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
1341                  decode_gesture(fifo_data + ii);
1342          
1343          //    get_ms(timestamp);
1344              return 0;
1345          }
C51 COMPILER V9.00   INV_MPU_DMP_MOTION_DRIVER                                             07/16/2014 23:48:00 PAGE 23  

1346          
1347          /**
1348           *  @brief      Register a function to be executed on a tap event.
1349           *  The tap direction is represented by one of the following:
1350           *  \n TAP_X_UP
1351           *  \n TAP_X_DOWN
1352           *  \n TAP_Y_UP
1353           *  \n TAP_Y_DOWN
1354           *  \n TAP_Z_UP
1355           *  \n TAP_Z_DOWN
1356           *  @param[in]  func    Callback function.
1357           *  @return     0 if successful.
1358           */
1359          int dmp_register_tap_cb(void (*func)(unsigned char, unsigned char))
1360          {
1361              dmp.tap_cb = func;
1362              return 0;
1363          }
1364          
1365          /**
1366           *  @brief      Register a function to be executed on a android orientation event.
1367           *  @param[in]  func    Callback function.
1368           *  @return     0 if successful.
1369           */
1370          int dmp_register_android_orient_cb(void (*func)(unsigned char))
1371          {
1372              dmp.android_orient_cb = func;
1373              return 0;
1374          }
1375          
1376          /**
1377           *  @}
1378           */
1379          

C51 COMPILATION COMPLETE.  5 WARNING(S),  6 ERROR(S)
